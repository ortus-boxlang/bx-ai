// production-ready.bxs
/**
 * Production-Ready AI Service
 * Complete example with all best practices
 */

println( "=== Production-Ready AI Service ===" )
println()

// Service class with all production features
class AIService {
    property name="cache" default={};
    property name="metrics" default={};
    property name="config" default={};

    function init( config = {} ) {
        variables.config = {
            maxRetries: 3,
            timeout: 30,
            cacheTTL: 60,
            providers: [ "openai", "claude" ]
        }.append( config )

        variables.cache = {}
        variables.metrics = {
            requests: 0,
            errors: 0,
            cacheHits: 0
        }

        return this
    }

    function chat( prompt, options = {} ) {
        // Validate input
        validatePrompt( prompt )

        // Check cache
        if ( shouldUseCache( options ) ) {
            cached = getFromCache( prompt )
            if ( !isNull( cached ) ) {
                variables.metrics.cacheHits++
                return cached
            }
        }

        // Execute with retry and fallback
        response = executeWithRetry( prompt, options )

        // Cache result
        if ( shouldUseCache( options ) ) {
            saveToCache( prompt, response )
        }

        return response
    }

    private function validatePrompt( prompt ) {
        if ( isNull( prompt ) || !len( trim( prompt ) ) ) {
            throw( type: "ValidationError", message: "Prompt cannot be empty" )
        }

        if ( len( prompt ) > 10000 ) {
            throw( type: "ValidationError", message: "Prompt exceeds maximum length" )
        }
    }

    private function executeWithRetry( prompt, options ) {
        retries = 0
        lastError = ""

        while ( retries < variables.config.maxRetries ) {
            try {
                variables.metrics.requests++

                result = aiChat(
                    prompt,
                    options.append( {
                        timeout: variables.config.timeout
                    } )
                )

                return result

            } catch( any e ) {
                retries++
                lastError = e.message
                variables.metrics.errors++

                if ( retries >= variables.config.maxRetries ) {
                    // Try fallback provider
                    if ( options.keyExists( "provider" ) ) {
                        return tryFallbackProvider( prompt, options )
                    }
                    throw e
                }

                // Exponential backoff
                sleep( 2 ^ retries * 1000 )
            }
        }
    }

    private function tryFallbackProvider( prompt, options ) {
        for ( provider in variables.config.providers ) {
            if ( provider != options.provider ) {
                try {
                    return aiChat( prompt, { provider: provider } )
                } catch( any e ) {
                    continue
                }
            }
        }

        throw( type: "ServiceError", message: "All providers failed" )
    }

    private function shouldUseCache( options ) {
        return options.cache ?: true
    }

    private function getFromCache( prompt ) {
        cacheKey = hash( prompt )

        if ( variables.cache.keyExists( cacheKey ) ) {
            entry = variables.cache[ cacheKey ]

            // Check TTL
            age = dateDiff( "n", entry.timestamp, now() )
            if ( age < variables.config.cacheTTL ) {
                return entry.response
            }

            variables.cache.delete( cacheKey )
        }

        return null
    }

    private function saveToCache( prompt, response ) {
        cacheKey = hash( prompt )
        variables.cache[ cacheKey ] = {
            response: response,
            timestamp: now()
        }
    }

    function getMetrics() {
        return {
            requests: variables.metrics.requests,
            errors: variables.metrics.errors,
            cacheHits: variables.metrics.cacheHits,
            errorRate: variables.metrics.requests > 0
                ? ( variables.metrics.errors / variables.metrics.requests ) * 100
                : 0,
            cacheHitRate: variables.metrics.requests > 0
                ? ( variables.metrics.cacheHits / variables.metrics.requests ) * 100
                : 0
        }
    }

    function clearCache() {
        variables.cache = {}
    }
}

// Usage example
println( "Initializing production AI service..." )
service = new AIService( {
    maxRetries: 2,
    timeout: 15,
    cacheTTL: 30
} )

println( "‚úì Service initialized" )
println()

// Test requests
testPrompts = [
    "What is 2+2?",
    "What is 2+2?",  // Should hit cache
    "What is 3+3?",
    "Explain AI briefly"
]

println( "Running test requests..." )
println( "-".repeat( 70 ) )

testPrompts.each( ( prompt, index ) => {
    println( "Request #index#: #prompt#" )

    try {
        response = service.chat( prompt )
        println( "Response: #left( response, 60 )#..." )
    } catch( any e ) {
        println( "‚ùå Error: #e.message#" )
    }

    println()
} )

// Show metrics
println( "=== Service Metrics ===" )
metrics = service.getMetrics()

println( "Total Requests: #metrics.requests#" )
println( "Errors: #metrics.errors#" )
println( "Cache Hits: #metrics.cacheHits#" )
println( "Error Rate: #numberFormat( metrics.errorRate, '0.00' )#%" )
println( "Cache Hit Rate: #numberFormat( metrics.cacheHitRate, '0.00' )#%" )
println()

println( "üí° Production Checklist:" )
println( "‚úì Input validation" )
println( "‚úì Error handling with retries" )
println( "‚úì Provider fallback" )
println( "‚úì Response caching" )
println( "‚úì Metrics tracking" )
println( "‚úì Timeout protection" )
println( "‚úì Configurable behavior" )
println( "‚úì Clean API" )
println()

println( "Next steps for full production:" )
println( "- Add structured logging (JSON format)" )
println( "- Integrate with monitoring (New Relic, DataDog)" )
println( "- Implement rate limiting" )
println( "- Add request queuing" )
println( "- Set up alerting" )
println( "- Add health checks" )
println( "- Implement circuit breaker" )
println( "- Add distributed caching (Redis)" )
println( "- Security: API key rotation, encryption" )
println( "- Load testing and optimization" )
