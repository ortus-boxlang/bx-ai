/**
 * Unit tests for AWS Signature V4 signing utility
 *
 * These tests verify the correctness of the AWS Signature Version 4 implementation
 * used by BedrockService for authenticating requests to AWS.
 *
 * @see https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
 */
class extends="testbox.system.BaseSpec" {

	function run() {

		describe( "AwsSignatureV4", () => {

			beforeEach( () => {
				variables.signer = new src.main.bx.models.util.AwsSignatureV4();
			} )

			describe( "Initialization", () => {

				it( "can be instantiated", () => {
					expect( signer ).notToBeNull();
				} )

			} )

			describe( "Request Signing", () => {

				it( "returns a struct with required headers", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "bedrock-runtime.us-east-1.amazonaws.com",
						path = "/model/anthropic.claude-3-sonnet/invoke",
						queryString = "",
						headers = { "content-type": "application/json" },
						payload = '{"message":"test"}',
						region = "us-east-1",
						service = "bedrock",
						accessKeyId = "AKIAIOSFODNN7EXAMPLE",
						secretAccessKey = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
					);

					expect( result ).toBeStruct();
					expect( result.keyExists( "Authorization" ) ).toBeTrue();
					expect( result.keyExists( "x-amz-date" ) ).toBeTrue();
					expect( result.keyExists( "x-amz-content-sha256" ) ).toBeTrue();
				} )

				it( "generates Authorization header with correct format", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "bedrock-runtime.eu-west-2.amazonaws.com",
						path = "/model/test-model/invoke",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "eu-west-2",
						service = "bedrock",
						accessKeyId = "AKIAEXAMPLE",
						secretAccessKey = "secretkey123"
					);

					var authHeader = result[ "Authorization" ];

					// Verify format: AWS4-HMAC-SHA256 Credential=.../aws4_request, SignedHeaders=..., Signature=...
					expect( authHeader ).toMatch( "^AWS4-HMAC-SHA256" );
					expect( authHeader ).toContain( "Credential=AKIAEXAMPLE/" );
					expect( authHeader ).toContain( "/eu-west-2/bedrock/aws4_request" );
					expect( authHeader ).toContain( "SignedHeaders=" );
					expect( authHeader ).toContain( "Signature=" );
				} )

				it( "includes session token header when provided", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "bedrock-runtime.us-east-1.amazonaws.com",
						path = "/model/test/invoke",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "bedrock",
						accessKeyId = "ASIATEMP123",
						secretAccessKey = "tempsecret",
						sessionToken = "FwoGZXIvYXdzEBYaDKtest123sessiontoken=="
					);

					expect( result.keyExists( "x-amz-security-token" ) ).toBeTrue();
					expect( result[ "x-amz-security-token" ] ).toBe( "FwoGZXIvYXdzEBYaDKtest123sessiontoken==" );
				} )

				it( "does not include session token when empty", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "bedrock-runtime.us-east-1.amazonaws.com",
						path = "/model/test/invoke",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "bedrock",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret",
						sessionToken = ""
					);

					expect( result.keyExists( "x-amz-security-token" ) ).toBeFalse();
				} )

				it( "generates correct payload hash for empty body", () => {
					var result = signer.signRequest(
						method = "GET",
						host = "example.amazonaws.com",
						path = "/",
						queryString = "",
						headers = {},
						payload = "",
						region = "us-east-1",
						service = "test",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					// SHA-256 of empty string is e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
					expect( result[ "x-amz-content-sha256" ] ).toBe( "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" );
				} )

				it( "generates correct payload hash for JSON body", () => {
					var payload = '{"test":"value"}';
					var result = signer.signRequest(
						method = "POST",
						host = "example.amazonaws.com",
						path = "/test",
						queryString = "",
						headers = {},
						payload = payload,
						region = "us-east-1",
						service = "test",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					// The hash should be lowercase hex
					expect( result[ "x-amz-content-sha256" ] ).toMatch( "^[a-f0-9]{64}$" );
				} )

				it( "generates x-amz-date in correct format", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "test.amazonaws.com",
						path = "/",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "test",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					// Format should be: YYYYMMDDTHHmmssZ
					expect( result[ "x-amz-date" ] ).toMatch( "^\d{8}T\d{6}Z$" );
				} )

			} )

			describe( "Canonical Headers", () => {

				it( "includes host in signed headers", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "test.amazonaws.com",
						path = "/",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "test",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					expect( result[ "Authorization" ] ).toContain( "SignedHeaders=" );
					expect( result[ "Authorization" ] ).toContain( "host" );
				} )

				it( "includes x-amz-date in signed headers", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "test.amazonaws.com",
						path = "/",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "test",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					expect( result[ "Authorization" ] ).toContain( "x-amz-date" );
				} )

				it( "includes custom headers in signature", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "test.amazonaws.com",
						path = "/",
						queryString = "",
						headers = { "content-type": "application/json" },
						payload = "{}",
						region = "us-east-1",
						service = "test",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					expect( result[ "Authorization" ] ).toContain( "content-type" );
				} )

			} )

			describe( "URI Encoding", () => {

				it( "handles simple paths correctly", () => {
					// Test via the full signing process - if path encoding is wrong, signature will be different
					var result1 = signer.signRequest(
						method = "POST",
						host = "test.amazonaws.com",
						path = "/model/test",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "test",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					expect( result1[ "Authorization" ] ).toContain( "Signature=" );
				} )

				it( "handles paths with colons correctly", () => {
					// Bedrock model IDs often contain colons like anthropic.claude-3-sonnet-20240229-v1:0
					var result = signer.signRequest(
						method = "POST",
						host = "bedrock-runtime.us-east-1.amazonaws.com",
						path = "/model/anthropic.claude-3-sonnet-20240229-v1:0/invoke",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "bedrock",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					expect( result[ "Authorization" ] ).toContain( "Signature=" );
				} )

			} )

			describe( "Different Services", () => {

				it( "works with bedrock service", () => {
					var result = signer.signRequest(
						method = "POST",
						host = "bedrock-runtime.us-east-1.amazonaws.com",
						path = "/model/test/invoke",
						queryString = "",
						headers = {},
						payload = "{}",
						region = "us-east-1",
						service = "bedrock",
						accessKeyId = "AKIATEST",
						secretAccessKey = "secret"
					);

					expect( result[ "Authorization" ] ).toContain( "/bedrock/aws4_request" );
				} )

				it( "works with different regions", () => {
					var regions = [ "us-east-1", "us-west-2", "eu-west-1", "ap-southeast-1" ];

					for( var region in regions ) {
						var result = signer.signRequest(
							method = "POST",
							host = "bedrock-runtime.#region#.amazonaws.com",
							path = "/test",
							queryString = "",
							headers = {},
							payload = "{}",
							region = region,
							service = "bedrock",
							accessKeyId = "AKIATEST",
							secretAccessKey = "secret"
						);

						expect( result[ "Authorization" ] ).toContain( "/#region#/bedrock/aws4_request", "Failed for region: #region#" );
					}
				} )

			} )

			describe( "Consistency", () => {

				it( "generates consistent signatures for same inputs", () => {
					var args = {
						method: "POST",
						host: "test.amazonaws.com",
						path: "/test",
						queryString: "",
						headers: {},
						payload: '{"test":true}',
						region: "us-east-1",
						service: "test",
						accessKeyId: "AKIACONSISTENT",
						secretAccessKey: "consistentsecret"
					};

					// Sign twice with same inputs
					var result1 = signer.signRequest( argumentCollection = args );

					// Since x-amz-date changes each call, we can't compare exact signatures
					// But we can verify the format is consistent
					expect( result1[ "Authorization" ] ).toMatch( "^AWS4-HMAC-SHA256 Credential=" );
					expect( result1[ "x-amz-content-sha256" ] ).toMatch( "^[a-f0-9]{64}$" );
				} )

				it( "generates different signatures for different payloads", () => {
					var baseArgs = {
						method: "POST",
						host: "test.amazonaws.com",
						path: "/test",
						queryString: "",
						headers: {},
						region: "us-east-1",
						service: "test",
						accessKeyId: "AKIATEST",
						secretAccessKey: "secret"
					};

					var result1 = signer.signRequest(
						argumentCollection = baseArgs,
						payload = '{"message":"hello"}'
					);

					var result2 = signer.signRequest(
						argumentCollection = baseArgs,
						payload = '{"message":"goodbye"}'
					);

					// Content hashes should be different
					expect( result1[ "x-amz-content-sha256" ] ).notToBe( result2[ "x-amz-content-sha256" ] );
				} )

			} )

		} )

	}

}
