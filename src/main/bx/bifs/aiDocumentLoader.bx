/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * Create a document loader instance for advanced configuration and usage.
 * Returns the loader instance for method chaining and advanced operations.
 *
 * @example
 * ```
 * // Create and configure a markdown loader
 * loader = aiDocumentLoader( "/docs", "markdown" )
 *     .splitByHeaders( 2 )
 *     .removeCodeBlocks()
 *
 * // Create a directory loader with recursive scanning
 * loader = aiDocumentLoader( "/knowledge-base", "directory" )
 *     .recursive()
 *     .extensions( ["md", "txt"] )
 *
 * // Create an HTTP loader for URLs
 * loader = aiDocumentLoader( "https://example.com/page.html", "http" )
 *     .contentType( "html" )
 *     .extractText()
 *
 * // Create a Tika loader for PDFs and Office documents
 * loader = aiDocumentLoader( "/docs/report.pdf", "tika" )
 *
 * // Create a web crawler
 * loader = aiDocumentLoader( "https://example.com", "crawler" )
 *     .maxPages( 20 )
 *     .maxDepth( 3 )
 *
 * // Create an RSS/Atom feed loader
 * loader = aiDocumentLoader( "https://example.com/feed.xml", "feed" )
 *     .maxItems( 10 )
 *
 * // Create a SQL loader
 * loader = aiDocumentLoader( "SELECT * FROM articles", "sql" )
 *     .datasource( "mydb" )
 *     .contentColumn( "body" )
 *
 * // Load documents using the configured loader
 * docs = loader.load()
 * ```
 */
import bxModules.bxai.models.loaders.TextLoader;
import bxModules.bxai.models.loaders.MarkdownLoader;
import bxModules.bxai.models.loaders.CSVLoader;
import bxModules.bxai.models.loaders.JSONLoader;
import bxModules.bxai.models.loaders.XMLLoader;
import bxModules.bxai.models.loaders.DirectoryLoader;
import bxModules.bxai.models.loaders.HTTPLoader;
import bxModules.bxai.models.loaders.TikaLoader;
import bxModules.bxai.models.loaders.FeedLoader;
import bxModules.bxai.models.loaders.SQLLoader;
import bxModules.bxai.models.loaders.WebCrawlerLoader;

@BoxBIF
class {

	/**
	 * Static loader type mappings
	 */
	static {
		EXTENSION_MAP = {
			"txt"      : "text",
			"text"     : "text",
			"md"       : "markdown",
			"markdown" : "markdown",
			"csv"      : "csv",
			"json"     : "json",
			"xml"      : "xml",
			"rss"      : "feed",
			"atom"     : "feed",
			// Tika-supported formats
			"pdf"      : "tika",
			"doc"      : "tika",
			"docx"     : "tika",
			"xls"      : "tika",
			"xlsx"     : "tika",
			"ppt"      : "tika",
			"pptx"     : "tika",
			"odt"      : "tika",
			"ods"      : "tika",
			"odp"      : "tika",
			"rtf"      : "tika",
			"epub"     : "tika"
		};
	}

	/**
	 * Create a document loader instance
	 *
	 * @source The source to load from (file path, directory, URL, or SQL query)
	 * @type   Optional explicit loader type (text, markdown, csv, json, xml, directory, http, tika, feed, sql, crawler)
	 * @config Configuration options for the loader
	 *
	 * @return IDocumentLoader instance
	 */
	function invoke( required string source, string type = "", struct config = {} ) {
		var loaderType = arguments.type;

		// Auto-detect loader type if not specified
		if ( !len( loaderType ) ) {
			loaderType = detectLoaderType( arguments.source );
		}

		// Create the appropriate loader
		switch ( loaderType.lCase() ) {
			case "text":
			case "txt":
				return new TextLoader( source: arguments.source, config: arguments.config );

			case "markdown":
			case "md":
				return new MarkdownLoader( source: arguments.source, config: arguments.config );

			case "csv":
				return new CSVLoader( source: arguments.source, config: arguments.config );

			case "json":
				return new JSONLoader( source: arguments.source, config: arguments.config );

			case "xml":
				return new XMLLoader( source: arguments.source, config: arguments.config );

			case "directory":
			case "dir":
				return new DirectoryLoader( source: arguments.source, config: arguments.config );

			case "http":
			case "url":
			case "html":
			case "htm":
				return new HTTPLoader( source: arguments.source, config: arguments.config );

			case "tika":
			case "pdf":
			case "doc":
			case "docx":
				return new TikaLoader( source: arguments.source, config: arguments.config );

			case "feed":
			case "rss":
			case "atom":
				return new FeedLoader( source: arguments.source, config: arguments.config );

			case "sql":
			case "database":
			case "db":
				return new SQLLoader( source: arguments.source, config: arguments.config );

			case "crawler":
			case "webcrawler":
			case "scraper":
				return new WebCrawlerLoader( source: arguments.source, config: arguments.config );

			default:
				throw(
					type    : "aiDocumentLoader.UnknownLoaderType",
					message : "Unknown loader type: #loaderType#. Supported types: text, markdown, csv, json, xml, directory, http, tika, feed, sql, crawler"
				);
		}
	}

	/**
	 * Detect the loader type from the source
	 *
	 * @source The source path or URL
	 *
	 * @return The detected loader type
	 */
	private string function detectLoaderType( required string source ) {
		// Check if it's a directory
		if ( directoryExists( arguments.source ) ) {
			return "directory";
		}

		// Check if it's a URL - use HTTP loader
		if ( reFindNoCase( "^https?://", arguments.source ) ) {
			// Check if it's a feed URL
			if ( reFindNoCase( "\.(rss|atom|feed)(\.xml)?$", arguments.source ) ||
				 reFindNoCase( "/feed/?$", arguments.source ) ||
				 reFindNoCase( "/rss/?$", arguments.source ) ) {
				return "feed";
			}
			return "http";
		}

		// Check if it looks like a SQL query
		if ( reFindNoCase( "^\s*(SELECT|INSERT|UPDATE|DELETE|WITH)\s+", arguments.source ) ) {
			return "sql";
		}

		// Check file extension
		var extension = listLast( arguments.source, "." ).lCase();

		if ( static.EXTENSION_MAP.keyExists( extension ) ) {
			return static.EXTENSION_MAP[ extension ];
		}

		// Default to text
		return "text";
	}

}
