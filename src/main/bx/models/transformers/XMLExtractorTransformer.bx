/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * Transformer that extracts and validates XML from text responses.
 *
 * Features:
 * - Extract XML from markdown code blocks
 * - Extract XML from mixed text/XML responses
 * - Parse and validate XML structures
 * - Extract specific XPath queries
 * - Handle arrays of text containing XML
 */
class implements="ITransformer" {

	/**
	 * Current configuration
	 */
	property name="config" type="struct";

	/**
	 * Configuration options
	 */
	static {
		DEFAULT_CONFIG = {
			// Extraction options
			stripMarkdown     : true,   // Remove markdown code blocks around XML
			strictMode        : false,  // Throw error if XML not found/invalid
			// XPath extraction
			xPath             : "",     // XPath query to extract (e.g., "//item/@name")
			// Output options
			returnRaw         : false,  // Return raw XML string instead of parsed object
			// Validation
			caseSensitive     : true    // Case sensitivity for tag matching
		}
	}

	/**
	 * Initialize the XML extractor transformer
	 *
	 * @config Optional configuration struct
	 *
	 * @return This transformer instance
	 */
	function init( struct config = {} ) {
		variables.config = duplicate( static.DEFAULT_CONFIG ).append( arguments.config, true )
		return this
	}

	/**
	 * Configure the transformer with settings
	 *
	 * @config Configuration struct
	 *
	 * @return This transformer instance
	 */
	public ITransformer function configure( required struct config ) {
		variables.config.append( arguments.config, true )
		return this
	}

	/**
	 * Extract and parse XML from input
	 *
	 * @input The text containing XML (string or array of strings)
	 *
	 * @return The extracted XML (parsed or raw string)
	 */
	public any function transform( required any input ) {
		// Handle arrays by transforming each element
		if ( isArray( arguments.input ) ) {
			return arguments.input.map( text => extractXML( text ) )
		}

		// Handle single string
		return extractXML( arguments.input )
	}

	/**
	 * Extract XML from a single text string
	 *
	 * @text The text to extract XML from
	 *
	 * @return The extracted XML
	 */
	private any function extractXML( required string text ) {
		var xmlString = arguments.text.trim()

		// Strip markdown code blocks if configured
		if ( variables.config.stripMarkdown ) {
			xmlString = stripMarkdownCodeBlocks( xmlString )
		}

		// Try to find XML in the text
		xmlString = findXMLInText( xmlString )

		// If no XML found and strict mode, throw error
		if ( len( xmlString ) == 0 && variables.config.strictMode ) {
			throw(
				type    = "XMLExtractor.NoXMLFound",
				message = "No XML found in input text"
			)
		}

		// If no XML found and not strict, return empty struct
		if ( len( xmlString ) == 0 ) {
			return variables.config.returnRaw ? "" : {}
		}

		// Return raw if configured
		if ( variables.config.returnRaw ) {
			return xmlString
		}

		// Parse XML
		try {
			var parsed = xmlParse( xmlString, variables.config.caseSensitive )

			// Extract specific XPath if configured
			if ( len( variables.config.xPath ) > 0 ) {
				parsed = extractXPath( parsed, variables.config.xPath )
			}

			return parsed
		} catch ( any e ) {
			if ( variables.config.strictMode ) {
				throw(
					type    = "XMLExtractor.InvalidXML",
					message = "Failed to parse XML: " & e.message,
					detail  = "XML string: " & xmlString
				)
			}
			// Return empty struct on parse error when not strict
			return {}
		}
	}

	/**
	 * Strip markdown code blocks from text
	 *
	 * @text The text to process
	 *
	 * @return Text without markdown code blocks
	 */
	private string function stripMarkdownCodeBlocks( required string text ) {
		var result = arguments.text.trim()

		// Check for ```xml ... ``` pattern
		if ( result.findNoCase( "```xml" ) > 0 ) {
			// Find the start and end positions
			var startPos = result.findNoCase( "```xml" )
			var contentStart = startPos + 6 // Length of "```xml"
			// Skip any whitespace after ```xml
			while ( contentStart <= len( result ) && mid( result, contentStart, 1 ).trim() == "" ) {
				contentStart++
			}
			// Find closing ```
			var endPos = result.find( "```", contentStart )
			if ( endPos > 0 ) {
				return mid( result, contentStart, endPos - contentStart ).trim()
			}
		}
		
		// Check for ``` ... ``` pattern (no language)
		if ( result.startsWith( "```" ) ) {
			var contentStart = 4 // Position after ```
			// Skip any whitespace
			while ( contentStart <= len( result ) && mid( result, contentStart, 1 ).trim() == "" ) {
				contentStart++
			}
			// Find closing ```
			var endPos = result.find( "```", contentStart )
			if ( endPos > 0 ) {
				return mid( result, contentStart, endPos - contentStart ).trim()
			}
		}

		// Remove single backticks around XML-like content
		if ( result.startsWith( "`" ) && result.endsWith( "`" ) && len( result ) > 2 ) {
			return mid( result, 2, len( result ) - 2 ).trim()
		}

		return result.trim()
	}

	/**
	 * Find XML in mixed text
	 *
	 * @text The text to search
	 *
	 * @return The XML string or empty string if not found
	 */
	private string function findXMLInText( required string text ) {
		var content = arguments.text.trim()

		// If it's already valid XML, return it
		if ( isXML( content ) ) {
			return content
		}

		// Try to find XML declaration
		var xmlDeclPos = content.find( "<?xml" )
		if ( xmlDeclPos > 0 ) {
			// Extract from XML declaration to end
			var extracted = content.substring( xmlDeclPos - 1 )
			// Try to find the end of the root element
			var rootStart = extracted.find( ">" ) + 1
			if ( rootStart > 1 ) {
				// Find the first opening tag after declaration
				var tagNameStart = extracted.find( "<", rootStart )
				if ( tagNameStart > 0 ) {
					var tagName = extractTagName( extracted, tagNameStart )
					if ( len( tagName ) > 0 ) {
						// Find closing tag
						var closeTag = "</" & tagName & ">"
						var closePos = extracted.find( closeTag )
						if ( closePos > 0 ) {
							return extracted.substring( 0, closePos + len( closeTag ) - 1 ).trim()
						}
					}
				}
			}
		}

		// Try to find XML by looking for opening tag
		var tagStart = content.find( "<" )
		if ( tagStart > 0 ) {
			var tagName = extractTagName( content, tagStart )
			if ( len( tagName ) > 0 ) {
				var closeTag = "</" & tagName & ">"
				var closePos = content.find( closeTag, tagStart )
				if ( closePos > 0 ) {
					var xmlCandidate = content.substring( tagStart - 1, closePos + len( closeTag ) - 1 ).trim()
					if ( isXML( xmlCandidate ) ) {
						return xmlCandidate
					}
				}
			}
		}

		return ""
	}

	/**
	 * Extract tag name from XML starting at a position
	 *
	 * @text The text containing the tag
	 * @startPos The position where the < is found
	 *
	 * @return The tag name or empty string
	 */
	private string function extractTagName( required string text, required numeric startPos ) {
		var pos = arguments.startPos + 1 // Position after <
		var len = len( arguments.text )
		var tagName = ""

		// Skip whitespace
		while ( pos <= len && mid( arguments.text, pos, 1 ).trim() == "" ) {
			pos++
		}

		// Extract tag name (alphanumeric, colon for namespaces, dash, underscore)
		while ( pos <= len ) {
			var char = mid( arguments.text, pos, 1 )
			// Check if valid tag name character
			if ( 
				( char >= "a" && char <= "z" ) || 
				( char >= "A" && char <= "Z" ) || 
				( char >= "0" && char <= "9" && len( tagName ) > 0 ) ||
				char == ":" || char == "-" || char == "_"
			) {
				tagName &= char
				pos++
			} else {
				break
			}
		}

		return tagName
	}

	/**
	 * Extract values using XPath query
	 *
	 * @xmlDoc The parsed XML document
	 * @xPath The XPath query
	 *
	 * @return The extracted value(s)
	 */
	private any function extractXPath( required any xmlDoc, required string xPath ) {
		try {
			var results = xmlSearch( arguments.xmlDoc, arguments.xPath )
			
			// If no results, return empty array
			if ( !isArray( results ) || arrayLen( results ) == 0 ) {
				return []
			}

			// If single result, return it directly
			if ( arrayLen( results ) == 1 ) {
				var result = results[ 1 ]
				// If it's a simple value (text node or attribute), return the string
				if ( isSimpleValue( result ) ) {
					return result
				}
				// Otherwise return the XML node
				return result
			}

			// Multiple results, return array
			return results
		} catch ( any e ) {
			throw(
				type    = "XMLExtractor.XPathError",
				message = "Failed to execute XPath query: " & e.message,
				detail  = "XPath: " & arguments.xPath
			)
		}
	}

}
