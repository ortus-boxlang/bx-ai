/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * Transformer that extracts code blocks from text responses.
 *
 * Features:
 * - Extract code by language (javascript, python, sql, etc.)
 * - Extract all code blocks regardless of language
 * - Support multiple code blocks of the same language
 * - Return metadata (language, line numbers)
 * - Handle code blocks with and without language identifiers
 */
class implements="ITransformer" {

	/**
	 * Current configuration
	 */
	property name="config" type="struct";

	/**
	 * Configuration options
	 */
	static {
		DEFAULT_CONFIG = {
			// Language selection
			language          : "all",      // "all" or specific language like "javascript", "python"
			// Multiple blocks
			multiple          : false,      // Return array of all blocks vs first block only
			// Metadata
			returnMetadata    : false,      // Return { language, code } vs just code string
			// Cleaning options
			stripComments     : false,      // Remove comments from code
			trim              : true,       // Trim whitespace
			// Markdown handling
			stripMarkdown     : true,       // Remove markdown code block wrappers
			// Validation
			strictMode        : false,      // Throw error if no code found
			// Fallback for no language identifier
			defaultLanguage   : "text"      // Default when no language specified in ```
		}
	}

	/**
	 * Initialize the code extractor transformer
	 *
	 * @config Optional configuration struct
	 *
	 * @return This transformer instance
	 */
	function init( struct config = {} ) {
		variables.config = duplicate( static.DEFAULT_CONFIG ).append( arguments.config, true )
		return this
	}

	/**
	 * Configure the transformer with settings
	 *
	 * @config Configuration struct
	 *
	 * @return This transformer instance
	 */
	public ITransformer function configure( required struct config ) {
		variables.config.append( arguments.config, true )
		return this
	}

	/**
	 * Extract code blocks from input
	 *
	 * @input The text containing code blocks (string or array of strings)
	 *
	 * @return The extracted code (string, array, or metadata structs)
	 */
	public any function transform( required any input ) {
		// Handle arrays by transforming each element
		if ( isArray( arguments.input ) ) {
			return arguments.input.map( text => extractCode( text ) )
		}

		// Handle single string
		return extractCode( arguments.input )
	}

	/**
	 * Extract code from a single text string
	 *
	 * @text The text to extract code from
	 *
	 * @return The extracted code
	 */
	private any function extractCode( required string text ) {
		var content = arguments.text.trim()
		var codeBlocks = []

		// Find all code blocks
		if ( variables.config.stripMarkdown ) {
			codeBlocks = findMarkdownCodeBlocks( content )
		} else {
			// If not stripping markdown, treat whole text as code
			codeBlocks = [ {
				language : variables.config.defaultLanguage,
				code     : content
			} ]
		}

		// Filter by language if specified
		if ( variables.config.language != "all" ) {
			codeBlocks = codeBlocks.filter( block =>
				block.language.toLowerCase() == variables.config.language.toLowerCase()
			)
		}

		// If no code found and strict mode, throw error
		if ( arrayLen( codeBlocks ) == 0 && variables.config.strictMode ) {
			throw(
				type    = "CodeExtractor.NoCodeFound",
				message = "No code blocks found for language: " & variables.config.language
			)
		}

		// If no code found and not strict, return appropriate empty value
		if ( arrayLen( codeBlocks ) == 0 ) {
			return variables.config.multiple ? [] : ""
		}

		// Process each code block
		codeBlocks = codeBlocks.map( block => processCodeBlock( block ) )

		// Return based on configuration
		if ( variables.config.multiple ) {
			// Return all blocks
			return variables.config.returnMetadata ? codeBlocks : codeBlocks.map( b => b.code )
		} else {
			// Return first block only
			var firstBlock = codeBlocks[ 1 ]
			return variables.config.returnMetadata ? firstBlock : firstBlock.code
		}
	}

	/**
	 * Find markdown code blocks in text
	 *
	 * @text The text to search
	 *
	 * @return Array of code block structs
	 */
	private array function findMarkdownCodeBlocks( required string text ) {
		var blocks = []
		var content = arguments.text
		var pos = 1
		var textLen = len( content )

		while ( pos <= textLen ) {
			// Find opening ```
			var openPos = content.find( "```", pos )
			if ( openPos == 0 ) {
				break
			}

			// Extract language identifier (everything from ``` to newline)
			var afterTicks = openPos + 3
			var langEnd = afterTicks
			var language = variables.config.defaultLanguage

			// Skip to end of line to get language
			while ( langEnd <= textLen && mid( content, langEnd, 1 ) != char( 10 ) && mid( content, langEnd, 1 ) != char( 13 ) ) {
				langEnd++
			}

			if ( langEnd > afterTicks ) {
				language = mid( content, afterTicks, langEnd - afterTicks ).trim()
				// If language is empty, use default
				if ( len( language ) == 0 ) {
					language = variables.config.defaultLanguage
				}
			}

			// Find code start (after language line)
			var codeStart = langEnd
			// Skip newline characters
			while ( codeStart <= textLen && ( mid( content, codeStart, 1 ) == char( 10 ) || mid( content, codeStart, 1 ) == char( 13 ) ) ) {
				codeStart++
			}

			// Find closing ```
			var closePos = content.find( "```", codeStart )
			if ( closePos == 0 ) {
				// No closing backticks, take rest of text
				closePos = textLen + 1
			}

			// Extract code
			var code = ""
			if ( closePos > codeStart ) {
				code = mid( content, codeStart, closePos - codeStart ).trim()
			}

			// Add to blocks
			blocks.append( {
				language : language,
				code     : code
			} )

			// Move position past the closing ```
			pos = closePos + 3
		}

		return blocks
	}

	/**
	 * Process a code block (cleaning, trimming, etc.)
	 *
	 * @block The code block struct
	 *
	 * @return Processed code block struct
	 */
	private struct function processCodeBlock( required struct block ) {
		var code = arguments.block.code

		// Strip comments if configured
		if ( variables.config.stripComments ) {
			code = stripComments( code, arguments.block.language )
		}

		// Trim if configured
		if ( variables.config.trim ) {
			code = code.trim()
		}

		return {
			language : arguments.block.language,
			code     : code
		}
	}

	/**
	 * Strip comments from code based on language
	 *
	 * @code The code to strip comments from
	 * @language The programming language
	 *
	 * @return Code without comments
	 */
	private string function stripComments( required string code, required string language ) {
		var result = arguments.code
		var lang = arguments.language.toLowerCase()

		// C-style comments (JavaScript, Java, C++, etc.)
		if (
			lang == "javascript" || lang == "java" || lang == "c" ||
			lang == "cpp" || lang == "csharp" || lang == "php" ||
			lang == "typescript" || lang == "boxlang" || lang == "cfml"
		) {
			// Remove single-line comments: // ...
			result = result.reReplace( "//[^\n\r]*", "", "all" )
			// Remove multi-line comments: /* ... */
			result = result.reReplace( "/\*.*?\*/", "", "all" )
		}
		// Python/Ruby style comments
		else if ( lang == "python" || lang == "ruby" || lang == "shell" || lang == "bash" ) {
			// Remove comments starting with hash
			var hashChar = char(35)
			result = result.reReplace( "#hashChar#[^\n\r]*", "", "all" )
		}
		// SQL comments
		else if ( lang == "sql" ) {
			// Remove comments starting with double dash
			result = result.reReplace( "--[^\n\r]*", "", "all" )
			// Remove /* ... */ comments
			result = result.reReplace( "/\*.*?\*/", "", "all" )
		}
		// HTML/XML comments
		else if ( lang == "html" || lang == "xml" ) {
			// Remove <!-- ... --> comments
			result = result.reReplace( "<!--.*?-->", "", "all" )
		}

		return result
	}

}
