/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * In-memory audit store for development and testing.
 * Stores all audit entries in memory - data is lost on restart.
 * Implements automatic eviction when maxEntries limit is reached.
 */
import bxModules.bxai.models.audit.BaseAuditStore;

class extends="BaseAuditStore" {

	/**
	 * Array of all stored entries
	 */
	property name="entries" type="array";

	/**
	 * Index of entries by traceId for fast lookup
	 */
	property name="traceIndex" type="struct";

	/**
	 * Index of entries by spanId for fast lookup
	 */
	property name="spanIndex" type="struct";

	/**
	 * Unique instance identifier for lock names
	 */
	property name="instanceId" type="string";

	/**
	 * Maximum number of entries to store before eviction (0 = unlimited)
	 */
	property name="maxEntries" type="numeric" default=10000;

	/**
	 * Number of entries to evict when limit is reached (percentage of maxEntries)
	 */
	property name="evictionPercent" type="numeric" default=20;

	/**
	 * Default max entries constant
	 */
	static {
		final DEFAULT_MAX_ENTRIES = 10000
		final DEFAULT_EVICTION_PERCENT = 20
	}

	/**
	 * Constructor
	 */
	function init() {
		super.init();
		variables.entries = [];
		variables.traceIndex = {};
		variables.spanIndex = {};
		variables.instanceId = createUUID();
		variables.maxEntries = static.DEFAULT_MAX_ENTRIES;
		variables.evictionPercent = static.DEFAULT_EVICTION_PERCENT;
		return this;
	}

	/**
	 * Configure the store
	 *
	 * @config Configuration struct with optional: maxEntries, evictionPercent
	 *
	 * @return IAuditStore for chaining
	 */
	IAuditStore function configure( required struct config ) {
		super.configure( arguments.config );

		if ( arguments.config.keyExists( "maxEntries" ) ) {
			variables.maxEntries = arguments.config.maxEntries;
		}

		if ( arguments.config.keyExists( "evictionPercent" ) ) {
			variables.evictionPercent = min( 50, max( 5, arguments.config.evictionPercent ) );
		}

		return this;
	}

	/**
	 * Store a single audit entry
	 *
	 * Thread-safe: Uses exclusive lock to prevent race conditions during
	 * concurrent writes which could corrupt indexes or lose data.
	 *
	 * @entry The AuditEntry to store
	 *
	 * @return IAuditStore for chaining
	 */
	IAuditStore function store( required any entry ) {
		var entryData = entryToStruct( arguments.entry );

		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="exclusive" timeout="5" throwontimeout="true" {
				// Skip duplicate entries (same spanId already stored)
				// This prevents double-storage when both bx-ai storeEntry() and
				// application event listeners call store() for the same entry
				if ( variables.spanIndex.keyExists( entryData.spanId ) ) {
					return this;
				}

				// Check if eviction is needed before adding
				if ( variables.maxEntries > 0 && variables.entries.len() >= variables.maxEntries ) {
					evictOldEntries();
				}

				// Add to main entries array
				variables.entries.append( entryData );
				var entryIndex = variables.entries.len();

				// Index by traceId
				if ( !variables.traceIndex.keyExists( entryData.traceId ) ) {
					variables.traceIndex[ entryData.traceId ] = [];
				}
				variables.traceIndex[ entryData.traceId ].append( entryIndex );

				// Index by spanId
				variables.spanIndex[ entryData.spanId ] = entryIndex;
			}
		} catch ( "LockException" e ) {
			// Lock timeout - log error and announce failure for monitoring
			writeLog(
				text : "ERROR: MemoryAuditStore lock timeout after 5s during store(). Entry spanId=#entryData.spanId# was NOT stored.",
				type : "error",
				log  : "ai"
			);

			// Announce failure so monitoring systems can detect data loss
			try {
				BoxAnnounce( "onAuditStoreFailed", {
					storeType : "memory",
					operation : "store",
					reason    : "Lock timeout after 5s",
					spanId    : entryData.spanId,
					traceId   : entryData.traceId
				} );
			} catch ( any announceErr ) {
				// Fallback to stderr if announcement fails
				try {
					createObject( "java", "java.lang.System" ).err.println(
						"[bx-ai] MemoryAuditStore lock timeout - entry spanId=#entryData.spanId# was NOT stored. Announce failed: #announceErr.message#"
					);
				} catch ( any stderrErr ) {
					// All notification methods failed - nothing more we can do
				}
			}

			// Throw to indicate storage failure - caller must handle this
			throw(
				type    : "AuditStoreLockTimeout",
				message : "MemoryAuditStore lock timeout after 5s. Entry spanId=#entryData.spanId# was NOT stored.",
				detail  : "This may indicate high contention on the audit store. Consider using async storage or increasing lock timeout."
			);
		}

		return this;
	}

	/**
	 * Evict oldest entries when maxEntries limit is reached.
	 * Removes a percentage of entries based on evictionPercent setting.
	 */
	private void function evictOldEntries() {
		if ( variables.entries.isEmpty() ) {
			return;
		}

		// Calculate how many entries to remove
		var entriesToRemove = ceiling( variables.maxEntries * ( variables.evictionPercent / 100 ) );
		entriesToRemove = min( entriesToRemove, variables.entries.len() );

		if ( entriesToRemove <= 0 ) {
			return;
		}

		// Remove oldest entries (they're at the beginning of the array)
		variables.entries = variables.entries.slice( entriesToRemove + 1 );

		// Rebuild indexes after eviction
		rebuildIndexes();
	}

	/**
	 * Query audit entries with filters
	 *
	 * Thread-safe: Uses readonly lock to allow concurrent reads but prevent
	 * reading during writes.
	 *
	 * @filters Query filters struct
	 * @limit Maximum results to return
	 * @offset Pagination offset
	 * @orderBy Sort field
	 * @orderDir Sort direction
	 *
	 * @return Array of entry structs (struct representations, not AuditEntry objects)
	 * @throws AuditQueryTimeout when lock cannot be acquired within timeout
	 */
	array function query(
		struct filters   = {},
		numeric limit    = 100,
		numeric offset   = 0,
		string orderBy   = "startTime",
		string orderDir  = "desc"
	) {
		var localFilters = arguments.filters;
		var filtered = [];

		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="readonly" timeout="5" throwontimeout="true" {
				// Filter entries - create a copy to avoid holding lock during sort
				filtered = variables.entries.filter( entry => matchesFilters( entry, localFilters ) );
			}
		} catch ( "LockException" e ) {
			writeLog(
				text : "ERROR: MemoryAuditStore lock timeout during query(). Query could not be completed.",
				type : "error",
				log  : "ai"
			);
			// Throw to indicate query failure - callers must handle this
			// Returning empty results would be indistinguishable from "no matches found"
			throw(
				type    : "AuditQueryTimeout",
				message : "MemoryAuditStore lock timeout during query(). Results are unavailable.",
				detail  : "This may indicate high contention on the audit store. Try again or reduce concurrent access."
			);
		}

		// Sort using base class helper (outside lock since we're working with a copy)
		filtered = sortEntries( filtered, arguments.orderBy, arguments.orderDir );

		// Paginate
		var startIdx = arguments.offset + 1;
		var endIdx = min( startIdx + arguments.limit - 1, filtered.len() );

		if ( startIdx > filtered.len() ) {
			return [];
		}

		return filtered.slice( startIdx, endIdx - startIdx + 1 );
	}

	/**
	 * Get a complete trace by traceId
	 *
	 * Thread-safe: Uses readonly lock to allow concurrent reads.
	 *
	 * @traceId The trace identifier
	 *
	 * @return Struct with trace data (traceId, entries, summary)
	 * @throws AuditQueryTimeout when lock cannot be acquired within timeout
	 */
	struct function getTrace( required string traceId ) {
		var localTraceId = arguments.traceId;
		var traceEntries = [];

		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="readonly" timeout="5" throwontimeout="true" {
				traceEntries = variables.entries.filter( e => e.traceId == localTraceId );
			}
		} catch ( "LockException" e ) {
			writeLog(
				text : "ERROR: MemoryAuditStore lock timeout during getTrace(). Trace data unavailable for traceId=#localTraceId#.",
				type : "error",
				log  : "ai"
			);
			// Throw to indicate trace retrieval failure - callers must handle this
			// Returning empty trace would be indistinguishable from "trace not found"
			throw(
				type    : "AuditQueryTimeout",
				message : "MemoryAuditStore lock timeout during getTrace(). Trace data is unavailable for traceId=#localTraceId#.",
				detail  : "This may indicate high contention on the audit store. Try again or reduce concurrent access."
			);
		}

		return {
			traceId : localTraceId,
			entries : traceEntries,
			summary : calculateTraceSummary( traceEntries )
		};
	}

	/**
	 * Get a single entry by spanId
	 *
	 * Thread-safe: Uses readonly lock and validates entry after index lookup
	 * to handle potential stale indexes after eviction.
	 *
	 * @spanId The span identifier
	 *
	 * @return AuditEntry struct or empty struct if not found
	 * @throws AuditQueryTimeout when lock cannot be acquired within timeout
	 */
	struct function getById( required string spanId ) {
		var localSpanId = arguments.spanId;

		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="readonly" timeout="5" throwontimeout="true" {
				if ( variables.spanIndex.keyExists( localSpanId ) ) {
					var idx = variables.spanIndex[ localSpanId ];
					if ( idx <= variables.entries.len() ) {
						var entry = variables.entries[ idx ];
						// Verify the entry is actually the one we want (handles stale index after eviction)
						if ( entry.spanId == localSpanId ) {
							return entry;
						}
					}
				}

				// Fallback to linear search
				var found = variables.entries.filter( e => e.spanId == localSpanId );
				return found.isEmpty() ? {} : found.first();
			}
		} catch ( "LockException" e ) {
			writeLog(
				text : "ERROR: MemoryAuditStore lock timeout during getById(). Entry data unavailable for spanId=#localSpanId#.",
				type : "error",
				log  : "ai"
			);
			// Throw to indicate retrieval failure - callers must handle this
			// Returning empty struct would be indistinguishable from "entry not found"
			throw(
				type    : "AuditQueryTimeout",
				message : "MemoryAuditStore lock timeout during getById(). Entry data is unavailable for spanId=#localSpanId#.",
				detail  : "This may indicate high contention on the audit store. Try again or reduce concurrent access."
			);
		}
	}

	/**
	 * Delete entries older than specified date
	 *
	 * Thread-safe: Uses exclusive lock to prevent race conditions.
	 *
	 * @olderThan Delete entries before this date
	 *
	 * @return Numeric count of deleted entries
	 */
	numeric function purge( required date olderThan ) {
		var localOlderThan = arguments.olderThan;
		var deletedCount = 0;

		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="exclusive" timeout="5" throwontimeout="true" {
				var initialCount = variables.entries.len();
				variables.entries = variables.entries.filter( e => e.startTime >= localOlderThan );
				deletedCount = initialCount - variables.entries.len();

				// Rebuild indexes
				rebuildIndexes();
			}
		} catch ( "LockException" e ) {
			writeLog(
				text : "WARNING: MemoryAuditStore lock timeout during purge(). No entries were purged.",
				type : "warning",
				log  : "ai"
			);
		}

		return deletedCount;
	}

	/**
	 * Delete a specific trace
	 *
	 * Thread-safe: Uses exclusive lock to prevent race conditions.
	 *
	 * @traceId The trace to delete
	 *
	 * @return Boolean success
	 */
	boolean function deleteTrace( required string traceId ) {
		var localTraceId = arguments.traceId;
		var wasDeleted = false;

		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="exclusive" timeout="5" throwontimeout="true" {
				var initialCount = variables.entries.len();
				variables.entries = variables.entries.filter( e => e.traceId != localTraceId );

				// Remove from trace index
				variables.traceIndex.delete( localTraceId );

				// Rebuild span index
				rebuildIndexes();

				wasDeleted = variables.entries.len() < initialCount;
			}
		} catch ( "LockException" e ) {
			writeLog(
				text : "WARNING: MemoryAuditStore lock timeout during deleteTrace(). Trace traceId=#localTraceId# was not deleted.",
				type : "warning",
				log  : "ai"
			);
		}

		return wasDeleted;
	}

	/**
	 * Get summary statistics
	 *
	 * Thread-safe: Uses readonly lock to allow concurrent reads.
	 *
	 * @filters Optional filters
	 *
	 * @return Struct with stats (totalEntries, totalTraces, bySpanType, byOperation, avgDurationMs)
	 * @throws AuditQueryTimeout when lock cannot be acquired within timeout
	 */
	struct function getStats( struct filters = {} ) {
		var localFilters = arguments.filters;
		var filtered = [];

		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="readonly" timeout="5" throwontimeout="true" {
				filtered = variables.entries.filter( entry => matchesFilters( entry, localFilters ) );
			}
		} catch ( "LockException" e ) {
			writeLog(
				text : "ERROR: MemoryAuditStore lock timeout during getStats(). Statistics unavailable.",
				type : "error",
				log  : "ai"
			);
			// Throw to indicate stats retrieval failure - callers must handle this
			// Returning zero stats would be indistinguishable from "no entries exist"
			throw(
				type    : "AuditQueryTimeout",
				message : "MemoryAuditStore lock timeout during getStats(). Statistics are unavailable.",
				detail  : "This may indicate high contention on the audit store. Try again or reduce concurrent access."
			);
		}

		var bySpanType = {};
		var byOperation = {};
		var totalDuration = 0;
		var traceIds = {};

		for ( var entry in filtered ) {
			// Count by spanType
			bySpanType[ entry.spanType ] = ( bySpanType[ entry.spanType ] ?: 0 ) + 1;

			// Count by operation
			byOperation[ entry.operation ] = ( byOperation[ entry.operation ] ?: 0 ) + 1;

			// Sum duration
			totalDuration += entry.durationMs ?: 0;

			// Track unique traces
			traceIds[ entry.traceId ] = true;
		}

		return {
			totalEntries  : filtered.len(),
			totalTraces   : traceIds.count(),
			bySpanType    : bySpanType,
			byOperation   : byOperation,
			avgDurationMs : filtered.len() > 0 ? totalDuration / filtered.len() : 0
		};
	}

	/**
	 * Clear all entries (for testing)
	 *
	 * Thread-safe: Uses exclusive lock to prevent race conditions.
	 *
	 * @return IAuditStore for chaining
	 */
	IAuditStore function clear() {
		try {
			lock name="MemoryAuditStore_#variables.instanceId#" type="exclusive" timeout="5" throwontimeout="true" {
				variables.entries = [];
				variables.traceIndex = {};
				variables.spanIndex = {};
			}
		} catch ( "LockException" e ) {
			writeLog(
				text : "WARNING: MemoryAuditStore lock timeout during clear(). Store may not be fully cleared.",
				type : "warning",
				log  : "ai"
			);
		}
		return this;
	}

	/**
	 * Close the store
	 *
	 * @return IAuditStore for chaining
	 */
	IAuditStore function close() {
		this.clear();
		return this;
	}

	// ========================================
	// Private Helper Methods
	// ========================================

	/**
	 * Rebuild all indexes from entries array
	 */
	private void function rebuildIndexes() {
		variables.traceIndex = {};
		variables.spanIndex = {};

		for ( var i = 1; i <= variables.entries.len(); i++ ) {
			var entry = variables.entries[ i ];

			// Trace index
			if ( !variables.traceIndex.keyExists( entry.traceId ) ) {
				variables.traceIndex[ entry.traceId ] = [];
			}
			variables.traceIndex[ entry.traceId ].append( i );

			// Span index
			variables.spanIndex[ entry.spanId ] = i;
		}
	}

}
