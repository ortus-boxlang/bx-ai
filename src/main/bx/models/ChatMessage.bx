/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * This class represents a chat conversation.  It holds a collection of messages
 * that have been added to the chat.
 * Please note that AI services only allow 1 `system` message per request.
 */
class{

	/**
	 * The collection of messages in the chat
	 */
	property name="messages" type="array" default=[];

    /**
     * A collection of bindings for the chat message
     */
    property name="bindings" type="struct" default={};

	/**
	 * CONSTANTS
	 */
	static{
		final DEFAULT_ROLE = 'user'
	}

	/**
	 * Construct a new message holder
	 *
	 * @message The initial message to add to the chat: string, struct, or array, or null
	 */
	function init( any message ){
		if( !isNull( arguments.message ) ){
			this.add( message )
		}
		return this
	}

	/**
	 * Count how many messages we have
	 */
	numeric function count() {
		return variables.messages.len()
	}

	/**
	 * Clear all messages
	 */
	ChatMessage function clear() {
		variables.messages = []
		return this
	}

	/**
	 * Verifies if there is a system message already in the chat
	 */
	boolean function hasSystemMessage() {
		return variables.messages.filter( message -> message?.role == 'system' ).len() > 0
	}

	/**
	 * Store bindings for later formatting/rendering
	 *
	 * @bindings A struct of key-value pairs to use for string replacement
	 *
	 * @return The chat message instance
	 */
	ChatMessage function bind( required struct bindings ) {
		variables.bindings = arguments.bindings
		return this
	}

	/**
	 * Format the messages with the provided bindings using stringBind()
	 *
	 * @bindings A struct of key-value pairs to use for string replacement
	 *
	 * @return An array of formatted messages
	 */
	array function format( required struct bindings ) {
		return variables.messages.map( message => {
            var formattedMessage = duplicate( message );
			if( isSimpleValue( formattedMessage.content ) ){
				formattedMessage.content = stringBind( formattedMessage.content, bindings )
			}
			return formattedMessage;
		} )
	}

	/**
	 * Render the messages using the stored bindings
	 *
	 * @return An array of formatted messages using the stored bindings
	 */
	array function render() {
		return format( variables.bindings )
	}

	/**
	 * Get the system message
	 *
	 * @return The system message or an empty string
	 */
	string function getSystemMessage() {
		return variables.messages
			.filter( message -> message?.role == 'system' )
			.map( message -> message.content )
			.reduce( ( acc, message ) => message, "" );
	}

	/**
	 * Replace the system message
	 *
	 * @content The new system message
	 */
	ChatMessage function replaceSystemMessage( required string content ) {
		if( !hasSystemMessage() ){
			return this;
		}
		// Find the location of the system message in the array
		var index = variables.messages.find( message => message.role == 'system' );
		// Replace the message
		variables.messages[ index ].content = arguments.content;
		return this;
	}

	/**
	 * Helper to get all messages that are not system messages
	 *
	 * @return An array of messages that are not system messages
	 */
	Array function getNonSystemMessages() {
		return variables.messages.filter( message -> message?.role != 'system' );
	}

	/**
	 * Adds a message to the chat.  The message content can be:
	 * - A string : The message will be added with the default role of user
	 * - A struct : The struct that represents the message according to the chat provider
	 * - An array : The array of messages to incorporate
	 *
	 * @content A string, struct, or array of messages to add to the chat
	 *
	 * @return The chat message instance
	 */
	ChatMessage function add( required any content ) {
		// Simple messages
		if( IsSimpleValue( arguments.content ) ){

			if( arguments.content.isEmpty() ){
				throw( "Cannot add an empty message" );
			}

			variables.messages.push( {
				"role" = static.DEFAULT_ROLE,
				"content" = arguments.content
			} );
		}
		// Struct messages
		else if( IsStruct( arguments.content ) ){
			// Default the role if non is provided
			param arguments.content.role = static.DEFAULT_ROLE;

			// System Message Rules
			if( arguments.content.role == 'system' && hasSystemMessage() ){
				// If the content is the same, ignore it, else replace it
				if( arguments.content.content == getSystemMessage() ){
					return this;
				}
				replaceSystemMessage( arguments.content.content );
				return this;
			}

			// Add the message
			variables.messages.push( arguments.content );
		} else if( IsArray( arguments.content ) ){
			arguments.content.each( message => this.add( message ) );
		} else {
			throw( 'Invalid content type. It must be a string, struct, or array' );
		}

		return this;
	}

	/**
	 * Dynamic messages using onMissingMethod.
	 * The missing method name should be add<role> where <role> is the role of the message.
	 */
	any function onMissingMethod( string name, struct args ){
		// The missing method is the role, the first argument is the message
		return this.add({
			"role" = arguments.name,
			"content" = arguments.args[ 1 ]
		});
	}

	/**
	 * Serialize this ChatMessage instance to a JSON string
	 *
	 * @return A JSON string representation of the ChatMessage
	 */
	string function toJson() {
		return serializeJSON( {
			"messages" = variables.messages,
			"bindings" = variables.bindings
		} );
	}

	/**
	 * Create a ChatMessage instance from a JSON string
	 *
	 * @json The JSON string to deserialize
	 *
	 * @return A new ChatMessage instance populated with the deserialized data
	 */
	static ChatMessage function fromJson( required string json ) {
		var data = deserializeJSON( arguments.json );
		var instance = new ChatMessage();
		
		// Restore messages if present
		if( structKeyExists( data, "messages" ) && isArray( data.messages ) ){
			instance.add( data.messages );
		}
		
		// Restore bindings if present
		if( structKeyExists( data, "bindings" ) && isStruct( data.bindings ) ){
			instance.bind( data.bindings );
		}
		
		return instance;
	}

}
