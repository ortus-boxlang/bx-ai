class extends="BaseService"{

	/**
	 * Constructor
	 */
	function init(){
		variables.chatURL = "https://generativelanguage.googleapis.com/v1beta/models/%MODEL%:generateContent"
		variables.embedURL = "https://generativelanguage.googleapis.com/v1beta/models/%MODEL%:embedContent"
		variables.name = "Gemini"
		defaults( {
			// according to the docs, this is the default model
			"model" : "gemini-2.0-flash"
		} )
	}

	/**
	 * Gemini chat request
	 */
	@override
	public function chat( required ChatRequest chatRequest ){
		// We need to pre-process the messages to conform to the Gemini API
		var dataPacket = {
			"contents": arguments.chatRequest
				.getMessages()
				.map( message -> {
					return {
						"role" : message.role == "system" ? "model" : "user",
						"parts": [ {
							"text": message.content
						} ]
					}
				} )
			}.append( arguments.chatRequest.getParams() )

		// Tooling support
		if( dataPacket.keyExists( "tools" ) ){
			dataPacket.tools = dataPacket.tools.map( .getSchema )
		}

		// Update URL according to the model
		variables.chatURL = getChatUrl().replace( '%MODEL%', chatRequest.getModel() ) & '?key=#chatRequest.getApiKey()#';
		// No auth header
		arguments.chatRequest.setSendAuthHeader( false );

		// Send it
		var result = sendRequest( chatRequest, dataPacket )

		// If an error is returned, throw it
		if( result.keyExists( "error" ) ){
			throw(
				type   : "ProviderError",
				message: result.error.toString()
			);
		}

		// No Tool calls yet.

		// Determine return formats
		switch( chatRequest.getReturnFormat() ){
			case "all":
				return result.candidates;
			case "raw":
				return result;
			case "single": default:
				return result.candidates.first().content.parts.first().text
		}

		/**
		 * ---------------------------------------------------------------------------------------------------------
		 * Tool Chains
		 * ---------------------------------------------------------------------------------------------------------
		 * TODO by Jacob here.
		 */

	}

	/**
	 * Gemini embedding request
	 */
	public function embed( required any embedRequest ){
		// Use the embedding model if not specified
		var model = arguments.embedRequest.model.len() ? arguments.embedRequest.model : "gemini-embedding-001";

		// Prepare the input(s) as required by Gemini API
		var inputs = arguments.embedRequest.inputs;
		if( !isArray( inputs ) ) inputs = [ inputs ];

		// Gemini API expects a "content" field with the text to embed
		var dataPacket = {
			"content": {
				"parts": inputs.map( txt => { "text": txt } )
			}
		};
		arguments.embedRequest.headers.append( { "x-goog-api-key": arguments.embedRequest.apiKey } );
		// No auth header
		arguments.embedRequest.setSendAuthHeader( false );

		// Set the embedURL for this request
		variables.embedURL = getEmbedUrl().replace( '%MODEL%', model ) & '?key=#arguments.embedRequest.apiKey#';

		// Call the BaseService sendEmbedRequest
		var result = sendEmbedRequest( arguments.embedRequest, dataPacket );

		// Log the raw response for debugging
		if( !isStruct(result) || structIsEmpty(result) ) {
			println( "[GeminiService] Raw response from Gemini API: " & serializeJson(result) );
			throw( type: "ProviderError", message: "Gemini API returned an empty or invalid response: " & serializeJson(result) );
		}

		// Parse embeddings from response
		var embeddings = [];
		if( result.keyExists( "embedding" ) ){
			// For single embedding, wrap in array for consistency
			embeddings = [ result.embedding.values ];
		} else if( result.keyExists( "embeddings" ) ){
			embeddings = result.embeddings.map( e => e.values );
		}

		// Determine return formats
		switch( arguments.embedRequest.getReturnFormat() ){
			case "all":
				return embeddings;
			case "raw":
				return result;
			case "single": default:
				// Return the first embedding as an array (not the array itself)
				return embeddings.len() ? embeddings[1] : [];
		}
	}

}
