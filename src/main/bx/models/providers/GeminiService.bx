/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 */
class extends="BaseService"{

	/**
	 * Static defaults
	 */
	static {
		DEFAULT_CHAT_PARAMS = {
			// https://ai.google.dev/gemini-api/docs/quickstart
			// according to the docs, this is the default model
			"model" : "gemini-2.5-flash"
		};
		DEFAULT_EMBED_PARAMS = {
			"model" : "text-embedding-004"
		};
	}

	/**
	 * Constructor
	 */
	function init(){
		variables.chatURL = "https://generativelanguage.googleapis.com/v1beta/models/%MODEL%:generateContent"
		variables.embeddingsURL = "https://generativelanguage.googleapis.com/v1beta/models/%MODEL%:embedContent"
		variables.name = "Gemini"
		defaults( static.DEFAULT_CHAT_PARAMS )
	}

	/**
	 * Override embeddings to handle Gemini's specific API format
	 * Gemini uses embedContent endpoint with model in URL and key as query param
	 * @see https://ai.google.dev/api/embeddings
	 */
	@override
	public function embeddings( required AiEmbeddingRequest embeddingRequest ){
		// Set default embedding model if not specified
		if( embeddingRequest.getModel().isEmpty() ){
			embeddingRequest.setModelIfEmpty( static.DEFAULT_EMBED_PARAMS.model )
		}

		// Model Selection
		embeddingRequest
			.setApiKeyIfEmpty( getAPIKey() )
			.mergeServiceParams( variables.params )
			.mergeServiceHeaders( variables.headers )

		// Build Gemini-specific data packet
		var input = arguments.embeddingRequest.getInput();
		var dataPacket = {
			"content": {
				"parts": [ {
					"text": isArray( input ) ? input.toList( " " ) : input
				} ]
			}
		}.append( arguments.embeddingRequest.getParams() )

		// Update URL with model and API key
		var requestURL = getEmbeddingsURL()
			.replace( '%MODEL%', embeddingRequest.getModel() )
			& '?key=#embeddingRequest.getApiKey()#';

		// Temporarily store the URL
		var originalURL = variables.embeddingsURL;
		variables.embeddingsURL = requestURL;

		// No auth header for Gemini
		embeddingRequest.setSendAuthHeader( false );

		// Send it
		var result = sendEmbeddingRequest( embeddingRequest, dataPacket )

		// Restore original URL
		variables.embeddingsURL = originalURL;

		// If an error is returned, throw it
		if( result.keyExists( "error" ) ){
			writeLog(
				text: result.error.toString(),
				type: "error",
				log : "ai"
			)
			throw(
				type   : "ProviderError",
				message: result.error.toString()
			);
		}

		// Convert Gemini response format to standard format
		var standardResponse = {
			"data": [ {
				"embedding": result.embedding.values,
				"index": 0
			} ],
			"model": embeddingRequest.getModel()
		}

		// Determine return formats
		switch( embeddingRequest.getReturnFormat() ){
			case "embeddings":
				return [ standardResponse.data.first().embedding ];
			case "first":
				return standardResponse.data.first().embedding;
			case "raw": default:
				return standardResponse;
		}
	}

	/**
	 * Gemini chat request
	 */
	@override
	public function chat( required AiRequest aiRequest ){
		// We need to pre-process the messages to conform to the Gemini API
		var dataPacket = {
			"contents": arguments.aiRequest
				.getMessages()
				.map( message -> {
					return {
						"role" : message.role == "system" ? "model" : "user",
						"parts": [ {
							"text": message.content
						} ]
					}
				} )
			}.append( arguments.aiRequest.getParams() )

		// Tooling support
		if( dataPacket.keyExists( "tools" ) ){
			dataPacket.tools = dataPacket.tools.map( .getSchema )
		}

		// Update URL according to the model
		variables.chatURL = getChatUrl().replace( '%MODEL%', aiRequest.getModel() ) & '?key=#aiRequest.getApiKey()#';
		// No auth header
		arguments.aiRequest.setSendAuthHeader( false );

		// Send it
		var result = sendRequest( aiRequest, dataPacket )

		// If an error is returned, throw it
		if( result.keyExists( "error" ) ){
			throw(
				type   : "ProviderError",
				message: result.error.toString()
			);
		}

		// No Tool calls yet.

		// Determine return formats
		var content = result.candidates.first().content.parts.first().text;
		switch( aiRequest.getReturnFormat() ){
			case "all":
				return result.candidates;
			case "raw":
				return result;
			case "json":
				return jsonDeserialize( extractFromCodeBlock( content, "json" ) );
			case "xml":
				return xmlParse( extractFromCodeBlock( content, "xml" ) );
			case "structuredOutput":
				return populateStructuredOutput( content, aiRequest );
			case "single": default:
				return content;
		}
	}

	/**
	 * Gemini streaming chat request - overridden to use Gemini-specific streaming format
	 * Gemini uses streamGenerateContent endpoint with ?alt=sse parameter
	 * @see https://ai.google.dev/gemini-api/docs/text-generation#rest_5
	 *
	 * @aiRequest The AiRequestobject to send to the provider
	 * @callback A callback function to be called with each chunk of the stream
	 */
	@override
	public function chatStream( required AiRequest aiRequest, required function callback ){
		// We need to pre-process the messages to conform to the Gemini API
		var dataPacket = {
			"contents": arguments.aiRequest
				.getMessages()
				.map( message -> {
					return {
						"role" : message.role == "system" ? "model" : "user",
						"parts": [ {
							"text": message.content
						} ]
					}
				} )
			}.append( arguments.aiRequest.getParams() )

		// Tooling support
		if( dataPacket.keyExists( "tools" ) ){
			dataPacket.tools = dataPacket.tools.map( .getSchema )
		}

		// Update URL for Gemini streaming: use streamGenerateContent endpoint with alt=sse
		var streamingURL = getChatUrl()
			.replace( '%MODEL%', aiRequest.getModel() )
			.replace( 'generateContent', 'streamGenerateContent' )
			& '?key=#aiRequest.getApiKey()#&alt=sse';

		// Set the streaming URL
		variables.chatURL = streamingURL;

		// No auth header for Gemini
		arguments.aiRequest.setSendAuthHeader( false );

		// Send it with streaming
		sendStreamRequest( aiRequest, dataPacket, callback )
	}

}
