/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 */
class extends="BaseService"{

	/**
	 * Static defaults
	 */
	static {
		DEFAULT_CHAT_PARAMS = {
			// according to the docs, this is the default model and tokens
			// https://docs.anthropic.com/en/docs/about-claude/models/overview#model-aliases
			"model" : "claude-sonnet-4-5",
			"max_tokens": 1024
		};
		DEFAULT_HEADERS = {
			// https://docs.anthropic.com/en/api/versioning
			"anthropic-version" : "2023-06-01"
		};
	}

	/**
	 * Constructor
	 */
	function init(){
		variables.chatURL = "https://api.anthropic.com/v1/messages"
		variables.name = "Claude"
		// https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview
		addHeader( name: "anthropic-version", value: static.DEFAULT_HEADERS[ "anthropic-version" ] )
	}

	/**
	 * Invoke a request to the provider
	 *
	 * @chatRequest The AI request to send to the provider
	 *
	 * @return The response from the provider according to the return format in the AI request
	 */
	function invoke( required AiChatRequest chatRequest ){
		// Seed the chat request with defaults
		arguments.chatRequest.mergeServiceParams( static.DEFAULT_CHAT_PARAMS )
		return super.invoke( arguments.chatRequest )
	}

	/**
	 * Invoke a request to the provider in streaming mode
	 *
	 * @chatRequest The Chat request to send to the provider
	 * @callback A callback function to be called with each chunk of the stream: function( chunk )
	 *
	 * @return void
	 */
	function invokeStream( required AiChatRequest chatRequest, required function callback ){
		// Seed the chat request with defaults
		arguments.chatRequest.mergeServiceParams( static.DEFAULT_CHAT_PARAMS )
		return super.invokeStream( arguments.chatRequest, arguments.callback )
	}

	/**
	 * Claude streaming chat request - overridden to use Claude-specific authentication
	 *
	 * @chatRequest The AiChatRequest object to send to the provider
	 * @callback A callback function to be called with each chunk of the stream
	 */
	@override
	public function chatStream( required AiChatRequest chatRequest, required function callback ){
		// Capture callback and chatRequest in local variables for closure scope
		var userCallback = arguments.callback;
		var thisChatRequest = arguments.chatRequest;

		// Build the packet according to Claude's API requirements with streaming
		var dataPacket = {
			"model"   : arguments.chatRequest.getModel(),
			"messages": arguments.chatRequest.getAiMessage().getNonSystemMessages(),
			"stream"  : true
		}.append( arguments.chatRequest.getParams() )

		// Do we have a system message? Claude supports it at the root
		if( arguments.chatRequest.getAiMessage().hasSystemMessage() ){
			dataPacket[ "system" ] = arguments.chatRequest.getAiMessage().getSystemMessage();
		}

		// Add tool support if tools are present
		if( arguments.chatRequest.getParams()?.tools?.len() ) {
			dataPacket[ "tools" ] = formatToolsForClaude( arguments.chatRequest.getParams().tools )
		}

		// Announce the request
		BoxAnnounce(
			"onAIChatRequest",
			{
				"dataPacket"    : dataPacket,
				"chatRequest"   : arguments.chatRequest,
				"provider"      : this,
				"auditMetadata" : arguments.chatRequest.getAuditMetadata()
			}
		);

		// Log the request if enabled
		if( arguments.chatRequest.getLogRequestToConsole() ){
			println( "AI Request (Stream)" )
			println( dataPacket )
		}

		// Build HTTP request with fluent API - Claude uses x-api-key instead of Bearer token
		var httpRequest = http( getChatURL() )
			.method( "POST" )
			.charset( "utf-8" )
			.timeout( arguments.chatRequest.getTimeout() )
			.header( "content-type", "application/json" )
			.header( "x-api-key", arguments.chatRequest.getApiKey() )
			.header( "anthropic-version", getHeaders()[ "anthropic-version" ] )
			.sse( true ); // Enable SSE mode for Claude streaming

		// Add custom headers
		for( var thisHeader in arguments.chatRequest.getHeaders() ){
			httpRequest.header( thisHeader, arguments.chatRequest.getHeaders()[ thisHeader ] );
		}

		// Set request body and callbacks
		httpRequest
			.body( jsonSerialize( dataPacket ) )
			.onChunk( ( chunk, lastEventId, httpResult, httpClient, response ) => {
				// chunk is already parsed SSE data: { data, event, id, retry }
				// For SSE streams, chunk.data contains the actual payload

				// Check for stream end marker
				if( chunk.data == "[DONE]" ){
					return;
				}

				// Try to parse and send to callback
				try {
					var parsedChunk = jsonDeserialize( chunk.data );
					userCallback( parsedChunk );
				} catch( any e ){
					writeLog(
						text: "Error parsing stream chunk: #e.message# - Data: #chunk.data#",
						type: "error",
						log : "ai"
					)
				}
			} )
			.onError( ( error, httpResult ) => {
				var errorMessage = "HTTP Error: #error.message#";

				writeLog(
					text: "Stream Request Error: #errorMessage#",
					type: "error",
					log : "ai"
				)

				// Announce the error
				BoxAnnounce( "onAIError", {
					error: error,
					errorMessage: errorMessage,
					provider: this,
					operation: "stream",
					aiRequest: thisChatRequest,
					canRetry: true
				} );

				throw(
					type   : "ProviderError",
					message: errorMessage
				);
			} )
			.onComplete( ( httpResult ) => {
				// Log the response if enabled
				if( thisChatRequest.getLogResponse() ){
					writeLog(
						text: "Stream completed successfully",
						type: "info",
						log : "ai"
					)
				}

				BoxAnnounce(
					"onAIChatResponse",
					{
						"chatRequest" : thisChatRequest,
						"provider"    : this,
						"streamComplete" : true
					}
				);
			} )
			.send();
	}

	/**
	 * Claude chat request
	 * Customized for Claude
	 * https://docs.anthropic.com/en/api/messages-examples
	 *
	 * @chatRequest The AIChatRequest object to send to the provider
	 * @interactionCount Current tool call interaction count (used internally)
	 *
	 * @throws ProviderError if the provider returns an error from the request
	 * @throws MaxInteractionsExceeded if tool calls exceed the maximum allowed interactions
	 */
	@override
	public function chat( required AiChatRequest chatRequest, numeric interactionCount = 0 ){
		// No auth header, claude uses x-api-key
		arguments.chatRequest
			.setSendAuthHeader( false )
			.addHeader( "x-api-key", arguments.chatRequest.getApiKey() )

		// Build the packet according to Claude's API requirements
		// https://docs.anthropic.com/en/api/messages#body-messages
		var dataPacket = {
			"model"   : arguments.chatRequest.getModel(),
			"messages": arguments.chatRequest.getMessages()
		}.append( arguments.chatRequest.getParams() )

		// Do we have a system message? Claude supports it at the root
		if( arguments.chatRequest.getAiMessage().hasSystemMessage() ){
			dataPacket[ "system" ] = arguments.chatRequest.getAiMessage().getSystemMessage();
		}

		// Add tool support if tools are present
		if( arguments.chatRequest.getParams()?.tools?.len() ) {
			dataPacket[ "tools" ] = formatToolsForClaude( arguments.chatRequest.getParams().tools )
		}

		// Send it
		var result = sendRequest( arguments.chatRequest, dataPacket )

		// If an error is returned, throw it
		if( result.keyExists( "error" ) ){
			writeLog(
				text: result.error.toString(),
				type: "error",
				log : "ai"
			)
			throw(
				type   : "ProviderError",
				message: result.error.toString()
			);
		}

		// Handle tool use responses
		// Check if Claude wants to use tools
		var usingTools = false
		for( var contentBlock in result.content ) {
			if( contentBlock?.type == "tool_use" ) {
				usingTools = true;
				break;
			}
		}

		// If Claude wants to use tools, we need to handle that
		if( usingTools ){
			/**
			 * ---------------------------------------------------------------------------------------------------------
			 * Max Interactions Check
			 * ---------------------------------------------------------------------------------------------------------
			 */
			var maxAllowed = arguments.chatRequest.getMaxInteractions() > 0 ? arguments.chatRequest.getMaxInteractions() : variables.maxInteractions;
			if( arguments.interactionCount >= maxAllowed ){
				writeLog(
					text: "Max tool call interactions (#maxAllowed#) exceeded",
					type: "error",
					log : "ai"
				)
				throw(
					type   : "MaxInteractionsExceeded",
					message: "Tool calls exceeded maximum allowed interactions (#maxAllowed#). This may indicate an infinite loop."
				);
			}

			var toolCalls = result.content.filter( contentBlock -> contentBlock?.type == "tool_use" );

			// Add the role assistant message with tool calls
			arguments.chatRequest.getMessages().append({
				"role"    : "assistant",
				"content" : result.content
			});

			// Create a new chat request for each tool call
			for( var toolCall in toolCalls ) {
				// Execute the tool call
				executeClaudeTool( toolCall, arguments.chatRequest );
			}

			// Recursively call chat with the updated chat request and incremented interaction count
			return chat( arguments.chatRequest, arguments.interactionCount + 1 );
		}

		// Determine return formats
		var content = result.content.first().text
		switch( arguments.chatRequest.getReturnFormat() ){
			case "all":
				return result.content;
			case "raw":
				return result;
			case "json":
				return JSONDeserialize( extractFromCodeBlock( content, "json" ) );
			case "xml" :
				return xmlParse( extractFromCodeBlock( content, "xml" ) );
			case  "structuredOutput":
				return populateStructuredOutput( content, arguments.chatRequest );
			case "single": default:
				return content;
		}
	}

	/**
	 * Format tools for Claude's specific tool format
	 * @see https://docs.anthropic.com/en/api/messages#body-tools
	 *
	 * @tools The tools to format
	 *
	 * @return An array of tools formatted for Claude
	 */
	private array function formatToolsForClaude( required array tools ) {
		var claudeTools = []

		for( var tool in arguments.tools ) {
			var argumentsSchema = tool.getArgumentsSchema();
			var claudeTool = {
				"name": tool.getName(),
				"description": tool.getDescription(),
				"input_schema": {
					"type": "object",
					"properties": argumentsSchema.properties,
					"required": argumentsSchema.required
				}
			}
			claudeTools.append( claudeTool )
		}

		return claudeTools
	}

	/**
	 * Execute Claude tool calls
	 *
	 * @toolCall The tool call object from Claude: { type:"tool_use", id: "", name: "toolName", input: {} }
	 * @chatRequest The original chat request containing the tool
	 */
	private function executeClaudeTool( required struct toolCall, required AiChatRequest chatRequest ) {
		var messages = arguments.chatRequest.getMessages();

		// Get the tool from the chat request
		arguments.chatRequest
			.getTool( toolCall.name )
			.ifPresentOrElse(
				// Found, invoke the tool
				tool => {
					messages.append({
						"role" : "user",
						"content" : [{
							"type"        : "tool_result",
							"tool_use_id" : toolCall.id,
							"content"     : tool.invoke( args : toolCall.input )
						}]
					});
				},
				// Not found
				() => {
					writeLog(
						text: "Unable to find tool named: [#toolCall.name#]",
						type: "warning",
						log : "ai"
					)
					messages.append({
						"role" : "user",
						"content" : [{
							"type"        : "tool_result",
							"tool_use_id" : toolCall.id,
							"content"     : "Tool ['#toolCall.name#'] not found in chat request"
						}]
					});
				}
			);
	}

}
