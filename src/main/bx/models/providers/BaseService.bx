/**
 * Base Service for AI Providers
 * This service provides a base implementation for AI providers
 * It is based on the Open AI standard, overridable by the provider
 * ----
 * All AI Providers must extend this service and implement the following methods:
 * - configure()
 * - invoke()
 *
 * All providers have the following properties:
 * - apiKey                                   : The API key to use with the provider
 * - chatURL                                  : The chat URL of the provider API
 * - params                                   : The default params request properties
 */
abstract class implements="IService" {

	/**
	 * The name of the LLM
	 */
	property name="name" default="";

	/**
	 * The API key to use with the provider
	 */
	property name = "apiKey" default = "";

	/**
	 * The chat URL of the provider API
	 */
	property name = "chatURL" default = "";

	/**
	 * The param request properties
	 */
	property name = "params" type = "struct" default = {};

	/**
	 * Constants
	 */
	static {
		final settings = getModuleInfo( "bx-ai" ).settings
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * Helper Methods
	 * ---------------------------------------------------------------------------------------------------------
	 */

	/**
	 * Set the default params for the provider
	 *
	 * @params - The params to set as defaults
	 *
	 * @return The service instance
	 */
	IService function defaults( required params ){
		variables.params.append( arguments.params, true );
		return this;
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * Interface Methods
	 * ---------------------------------------------------------------------------------------------------------
	 */

	 /**
	 * Configure the service with the API key
	 *
	 * @apiKey - The API key to use with the provider
	 *
	 * @return The service instance
	 */
	IService function configure( required any apiKey ){
		variables.apiKey = arguments.apiKey;
		return this;
	}

	/**
	 * Invoke a request to the provider
	 *
	 * @chatRequest The Chat request to send to the provider
	 *
	 * @return The response from the provider according to the return format in the chat request
	 */
	function invoke( required ChatRequest chatRequest ){
		// Seed the default params from the chat request, which overrides the service defaults
		defaults( chatRequest.getParams() )
		// Model Selection if not set, use the default in the service, which should always be set
		chatRequest.setModelIfEmpty( variables.params.model );
		chatRequest.setApiKeyIfEmpty( getAPIKey() );
		// Do a chat request
		// MORE TYPES CAN BE ADDED HERE LATER
		return chat( argumentCollection = arguments )
	}

	/**
	 * A chat method that sends messages to the provider.
	 * This method in this base class is based of OpenAI's standard.
	 * If the provider does not support this standard, it should override this method.
	 *
	 * @chatRequest The ChatRequest object to send to the provider
	 *
	 * @throws ProviderError if the provider returns an error from the request
	 *
	 * @return The response from the provider according to the return format in the chat request
	 */
	public function chat( required ChatRequest chatRequest ){
		// Build the packet according to the OpenAI standard
		var dataPacket = {
			"model"   : arguments.chatRequest.getModel(),
			"messages": arguments.chatRequest.getMessages()
		}.append( arguments.chatRequest.getParams() )

		// Tooling support
		if( dataPacket.keyExists( "tools" ) ){
			dataPacket.tools = dataPacket.tools.map( .getSchema )
		}

		// Send it
		var result = sendRequest( chatRequest, dataPacket )

		// If an error is returned, throw it
		if( result.keyExists( "error" ) ){
			throw(
				type   : "ProviderError",
				message: result.error.toString()
			);
		}

		// No Tool calls
		// TODO: Verify if all services support this.
		if( !result.choices[ 1 ].message.keyExists( "tool_calls" ) ){

			// Determine return formats
			switch( chatRequest.getReturnFormat() ){
				case "all":
					return result.choices;
				case "raw":
					return result;
				case "single": default:
					return result.choices[ 1 ].message.content;
			}
		}

		/**
		 * ---------------------------------------------------------------------------------------------------------
		 * Tool Chains
		 * ---------------------------------------------------------------------------------------------------------
		 * Move later to an interceptor
		 */
		var newMessages = chatRequest.getMessages().map( message -> message );
		result.choices.each( ( choice, i ) => {

			// add the tool call into our message history
			newMessages.append( choice.message );

			// find the tool, invoke it, append the result to the chat history
			choice.message.tool_calls.each( ( toolCall, i ) => {
				chatRequest.getTool( toolCall.function.name )
					.ifPresentOrElse(
						tool => {
							newMessages.append({
								"role"        : "tool",
								"tool_call_id": toolCall.id,
								"content"     : tool.invoke( JSONDeserialize( toolCall.function.arguments ) )
							});
						},
						() => writeLog(
							text: "Unable to find tool named: #toolCall.function.name#",
							type: "warning",
							log : "ai"
						)
					)
			});
		});

		chatRequest.setMessages( newMessages )

		return chat( chatRequest )
	}

	/**
	 * A generic HTTP proxy to send requests to the provider
	 *
	 * @chatRequest The ChatRequest object to use in the request
	 * @dataPacket The data packet to send to the provider
	 *
	 * @return The response from the provider as a struct
	 */
	private function sendRequest( required ChatRequest chatRequest, required struct dataPacket ){
		// Announce the request
		BoxAnnounce(
			"onAIRequest",
			{
				"dataPacket" : arguments.dataPacket,
				"chatRequest": arguments.chatRequest,
				"provider"   : this
			}
		);

		if( arguments.chatRequest.getLogRequest() ){
			// Log the request
			writeLog(
				text: "Request to AI Provider: #arguments.dataPacket.toString()#",
				type: "info",
				log : "ai"
			)
		}

		// println( dataPacket )

		bx: http
			url     = getChatURL()
			method  = "post"
			result  = "chatResult"
			charset = "utf-8"
			timeout = arguments.chatRequest.getTimeout()
		{
			bx:httpParam type="header" name="content-type" value="application/json";

			// Auth Header
			if( arguments.chatRequest.getSendAuthHeader() ){
				bx:httpParam type="header" name="Authorization" value="Bearer #arguments.chatRequest.getApiKey()#";
			}

			// Body Packet
			bx:httpParam type="body" value=jsonSerialize( arguments.dataPacket );
		}

		if( arguments.chatRequest.getLogResponse() ){
			// Log the request
			writeLog(
				text: "Reponse from AI Provider: #chatResult.toString()#",
				type: "info",
				log : "ai"
			)
		}

		var response = jsonDeserialize( chatResult.filecontent );

		BoxAnnounce(
			"onAIResponse",
			{
				"chatRequest"	 : arguments.chatRequest,
				"response"   	 : response,
				"rawResponse"	: chatResult,
				"provider"  	 : this
			}
		);

		return response;
	}

}
