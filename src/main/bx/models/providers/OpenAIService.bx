class extends="BaseService"{

	/**
	 * Constructor
	 */
	function init(){
		variables.chatURL = "https://api.openai.com/v1/chat/completions"
		variables.embedURL = "https://api.openai.com/v1/embeddings"
		variables.name = "OpenAI"
		defaults( {
			// according to the docs, this is the default model
			"model" : "gpt-4-turbo"
		} )
	}

	/**
	 * OpenAI embedding request
	 */
	public function embed( required any embedRequest ){
		// Use the embedding model if not specified
		var model = embedRequest.model.len() ? embedRequest.model : "text-embedding-3-small";

		// Prepare the input(s) as required by OpenAI API
		var inputs = embedRequest.inputs;
		if( !isArray( inputs ) ) inputs = [ inputs ];

		// OpenAI API expects an "input" field with the text(s) to embed
		var dataPacket = {
			"model": model,
			"input": inputs
		};

		// Set the embedURL for this request
		variables.embedURL = getEmbedUrl();

		// Call the BaseService sendEmbedRequest
		var result = sendEmbedRequest( embedRequest, dataPacket );

		// Log the raw response for debugging
		if( !isStruct(result) || structIsEmpty(result) ) {
			println( "[OpenAIService] Raw response from OpenAI API: " & serializeJson(result) );
			throw( type: "ProviderError", message: "OpenAI API returned an empty or invalid response: " & serializeJson(result) );
		}

		// Parse embeddings from response
		var embeddings = [];
		if( result.keyExists( "data" ) ){
			embeddings = result.data.map( e => e.embedding );
		}

		// Determine return formats
		switch( embedRequest.getReturnFormat() ){
			case "all":
				return embeddings;
			case "raw":
				return result;
			case "single": default:
				// Return the first embedding as an array (not the array itself)
				return embeddings.len() ? embeddings[1] : [];
		}
	}

}
