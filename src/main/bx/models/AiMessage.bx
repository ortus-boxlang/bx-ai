/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * This class represents a chat conversation.  It holds a collection of messages
 * that have been added to the chat.
 * Please note that AI services only allow 1 `system` message per request.
 *
 * This class extends AiBaseRunnable, making it usable in runnable pipelines.
 */
import bxModules.bxai.models.runnables.*;

class extends="AiBaseRunnable"{

	/**
	 * The collection of messages in the chat
	 */
	property name="messages" type="array" default=[];

    /**
     * A collection of bindings for the chat message
     */
    property name="bindings" type="struct" default={};

	/**
	 * CONSTANTS
	 */
	static{
		final DEFAULT_ROLE = 'user'
	}

	/**
	 * Construct a new message holder
	 *
	 * @message The initial message to add to the chat: string, struct, or array, or null
	 */
	function init( any message ){
		if( !isNull( arguments.message ) ){
			this.add( message )
		}
		return this
	}

	/**
	 * Count how many messages we have
	 */
	numeric function count() {
		return variables.messages.len()
	}

	/**
	 * Clear all messages
	 */
	AiMessage function clear() {
		variables.messages = []
		return this
	}

	/**
	 * Verifies if there is a system message already in the chat
	 */
	boolean function hasSystemMessage() {
		return variables.messages.filter( message -> message?.role == 'system' ).len() > 0
	}

	/**
	 * Store bindings for later formatting/rendering
	 *
	 * @bindings A struct of key-value pairs to use for string replacement
	 *
	 * @return The chat message instance
	 */
	AiMessage function bind( required struct bindings ) {
		variables.bindings = arguments.bindings
		return this
	}

	/**
	 * Format the messages with the provided bindings using stringBind()
	 *
	 * @bindings A struct of key-value pairs to use for string replacement
	 *
	 * @return An array of formatted messages
	 */
	array function format( required struct bindings ) {
		return variables.messages.map( message => {
            var formattedMessage = duplicate( message );
			if( isSimpleValue( formattedMessage.content ) ){
				formattedMessage.content = stringBind( formattedMessage.content, bindings )
			}
			return formattedMessage;
		} )
	}

	/**
	 * Render the messages using the stored bindings or optional provided bindings
     *
     * @bindings Optional bindings to merge with stored bindings for rendering
	 *
	 * @return An array of formatted messages using the stored bindings
	 */
	array function render( struct bindings = {} ) {
        // Merge provided bindings with stored bindings, in favor of provided
        var allBindings = arguments.bindings.append( variables.bindings, false )
		return format( allBindings )
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * IAiRunnable Interface Implementation
	 * ---------------------------------------------------------------------------------------------------------
	 */

	/**
	 * Run the message as a runnable - returns the formatted messages
	 * If input is provided and is a struct with bindings, it will be used for formatting
	 *
	 * @input Optional input, which is considered the bindings struct
	 * @params Optional parameters (ignored in this implementation)
	 *
	 * @return An array of formatted messages
	 */
	public any function run( any input = {}, struct params = {} ) {
        var incomingBindings = isStruct( arguments.input ) ? arguments.input : {}
		// Delegate to render with incoming bindings
		return render( incomingBindings );
	}

	/**
	 * Stream the messages through the callback
	 * Each message is sent as a separate chunk
	 *
	 * @onChunk The callback to invoke for each message
	 * @input Optional input with bindings
	 * @params Optional parameters
	 */
	public void function stream(
		required function onChunk,
		any input = {},
		struct params = {}
	) {
		var formattedMessages = run( arguments.input, arguments.params );
		var index = 1;

		for( var message in formattedMessages ) {
			arguments.onChunk( message, {
				step: "message",
				index: index,
				total: formattedMessages.len()
			} );
			index++;
		}
	}

	/**
	 * Get the system message
	 *
	 * @return The system message or an empty string
	 */
	string function getSystemMessage() {
		return variables.messages
			.filter( message -> message?.role == 'system' )
			.map( message -> message.content )
			.reduce( ( acc, message ) => message, "" );
	}

	/**
	 * Replace the system message
	 *
	 * @content The new system message
	 */
	AiMessage function replaceSystemMessage( required string content ) {
		if( !hasSystemMessage() ){
			return this;
		}
		// Find the location of the system message in the array
		var index = variables.messages.find( message => message.role == 'system' );
		// Replace the message
		variables.messages[ index ].content = arguments.content;
		return this;
	}

	/**
	 * Helper to get all messages that are not system messages
	 *
	 * @return An array of messages that are not system messages
	 */
	Array function getNonSystemMessages() {
		return variables.messages.filter( message -> message?.role != 'system' );
	}

	/**
	 * Prepends historical messages to the beginning of the current messages array.
	 * This is useful for maintaining conversation context by adding previous exchanges.
	 *
	 * @history An array of message structs or an AiMessage instance whose messages will be prepended
	 *
	 * @return The chat message instance for fluent chaining
	 */
	AiMessage function history( required any history ) {
		var historyMessages = [];

		// Extract messages from AiMessage instance or use array directly
		if( isObject( arguments.history ) && arguments.history.getClass().getName() contains "AiMessage" ){
			historyMessages = arguments.history.getMessages();
		} else if( isArray( arguments.history ) ){
			historyMessages = arguments.history;
		} else {
			throw( 'Invalid history type. It must be an array of messages or an AiMessage instance' );
		}

		// Prepend history messages to the beginning of the current messages
		variables.messages = historyMessages.append( variables.messages );

		return this;
	}

	/**
	 * Adds a message to the chat.  The message content can be:
	 * - A string : The message will be added with the default role of user
	 * - A struct : The struct that represents the message according to the chat provider
	 * - An array : The array of messages to incorporate
	 *
	 * @content A string, struct, or array of messages to add to the chat
	 *
	 * @return The chat message instance
	 */
	AiMessage function add( required any content ) {
		// Simple messages
		if( IsSimpleValue( arguments.content ) ){

			if( arguments.content.isEmpty() ){
				throw( "Cannot add an empty message" );
			}

			variables.messages.push( {
				"role" = static.DEFAULT_ROLE,
				"content" = arguments.content
			} );
		}
		// Struct messages
		else if( IsStruct( arguments.content ) ){
			// Default the role if non is provided
			param arguments.content.role = static.DEFAULT_ROLE;

			// System Message Rules
			if( arguments.content.role == 'system' && hasSystemMessage() ){
				// If the content is the same, ignore it, else replace it
				if( arguments.content.content == getSystemMessage() ){
					return this;
				}
				replaceSystemMessage( arguments.content.content );
				return this;
			}

			// Add the message
			variables.messages.push( arguments.content );
		} else if( IsArray( arguments.content ) ){
			arguments.content.each( message => this.add( message ) );
		} else {
			throw( 'Invalid content type. It must be a string, struct, or array' );
		}

		return this;
	}

	/**
	 * Dynamic messages using onMissingMethod.
	 * The missing method name should be add<role> where <role> is the role of the message.
	 */
	any function onMissingMethod( string name, struct args ){
		// The missing method is the role, the first argument is the message
		return this.add({
			"role" = arguments.name,
			"content" = arguments.args[ 1 ]
		});
	}

	/**
	 * Serialize this AiMessage instance to a JSON string
	 *
	 * @return A JSON string representation of the AiMessage
	 */
	string function toJson() {
		return jsonSerialize( variables.messages );
	}

	/**
	 * Create a AiMessage instance from a JSON string
	 *
	 * @json The JSON string to deserialize
	 *
	 * @return A new AiMessage instance populated with the deserialized data
	 */
	static AiMessage function fromJson( required string json ) {
		var messages = jsonDeserialize( arguments.json );
		var instance = new AiMessage();

		// Restore messages if present
		if( isArray( messages ) ){
			instance.add( messages );
		}

		return instance;
	}

}
