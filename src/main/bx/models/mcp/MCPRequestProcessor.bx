/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * MCP Request Processor
 *
 * Handles incoming HTTP requests for the MCP server endpoint.
 * This class encapsulates all request processing logic, including:
 * - CORS handling
 * - Request validation
 * - Response formatting (JSON and SSE)
 * - Error handling
 */
import bxModules.bxai.models.mcp.MCPServer
class {

	/**
	 * Static logger for MCP operations
	 */
	static {
		mcpLogger = getBoxRuntime().getLoggingService().getLogger( "mcp" )
        DEFAULT_SERVER_NAME = "default"
		DEFAULT_MCP_PROTOCOL_VERSION = "2024-11-05"
	}

	/**
	 * Render the result of an MCP request.
	 * Internally we processed an incoming HTTP request and produce the response.
	 * <strong>This method is only for web runtimes</strong>
	 *
	 * @return The rendered response content
	 */
	static string function render(){
		// Get request parameters
		var mcpServerName = url.server ?: "default"
		var requestMethod = cgi.REQUEST_METHOD
		var requestBody = requestMethod eq "POST" ? getHTTPRequestData().content : ""
		var acceptHeader = cgi.HTTP_ACCEPT ?: "application/json"

		// Check if we have a path_info segment for server name
		if ( len( cgi.PATH_INFO ) > 0 ) {
			var pathSegments = listToArray( cgi.PATH_INFO, "/" ).filter( segment => len( segment ) > 0 )
			if ( pathSegments.len() ) {
				mcpServerName = pathSegments.first()
			}
		}

		// Delegate to the request processor
		var result = process(
				serverName: mcpServerName,
				requestMethod: requestMethod,
				requestBody: requestBody,
				acceptHeader: acceptHeader,
				urlParams: url
			)

		// Set response headers
		for ( var headerName in result.headers ) {
			bx:header name=headerName value=result.headers[ headerName ];
		}

		// Set status code if not 200
		if ( result.statusCode neq 200 ) {
			bx:header statusCode=result.statusCode;
		}

		// render the content out
		bx:content
			type=result.contentType
			reset=true
			variable=result.content{}
	}

	/**
	 * Process an incoming MCP HTTP request
	 *
	 * @serverName The name of the MCP server to use
	 * @requestMethod The HTTP request method (GET, POST, OPTIONS)
	 * @requestBody The request body content (for POST requests)
	 * @acceptHeader The Accept header value
	 * @urlParams URL parameters struct
	 *
	 * @return Struct containing response data: { content, contentType, headers, statusCode }
	 */
	static struct function process(
		string serverName = static.DEFAULT_SERVER_NAME,
		required string requestMethod,
		string requestBody = "",
		string acceptHeader = "application/json",
		struct urlParams = {}
	) {
		// Verify server exists
		var targetServer = MCPServer::getInstance( arguments.serverName )
		if( isNull( targetServer ) ) {
			// Log it
			static.mcpLogger.error( "MCP Request for unknown server: #arguments.serverName#" )
			// Return error response with security headers
			return {
				"content": jsonSerialize( {
					"jsonrpc": "2.0",
					"error": {
						"code": MCPServer::errorCode( "INVALID_REQUEST" ),
						"message": "Unknown MCP server: " & arguments.serverName
					},
					"id": ""
				} ),
				"contentType": "application/json",
				"headers": {
					"X-Content-Type-Options": "nosniff",
					"X-Frame-Options": "DENY",
					"X-XSS-Protection": "1; mode=block"
				},
				"statusCode": 400
			}
		}

		// We have a server now, process it
		var response = {
			"content": "",
			"contentType": "application/json",
			"headers": {},
			"statusCode": 200
		}

		// Add standard security headers
		response.headers[ "X-Content-Type-Options" ] = "nosniff"
		response.headers[ "X-Frame-Options" ] = "DENY"
		response.headers[ "X-XSS-Protection" ] = "1; mode=block"
		response.headers[ "Referrer-Policy" ] = "strict-origin-when-cross-origin"
		response.headers[ "Content-Security-Policy" ] = "default-src 'none'; frame-ancestors 'none'"
		response.headers[ "Strict-Transport-Security" ] = "max-age=31536000; includeSubDomains"
		response.headers[ "Permissions-Policy" ] = "geolocation=(), microphone=(), camera=()"

		// Build request data for callbacks
		var requestData = {
			"serverName": arguments.serverName,
			"method": arguments.requestMethod,
			"body": arguments.requestBody,
			"acceptHeader": arguments.acceptHeader,
			"urlParams": arguments.urlParams
		}

		// Check request body size limit
		var maxBodySize = targetServer.getMaxRequestBodySize()
		if ( maxBodySize > 0 && len( arguments.requestBody ) > maxBodySize ) {
			static.mcpLogger.warn( "MCP request body size exceeded limit: #len( arguments.requestBody )# > #maxBodySize#" )
			response.statusCode = 413
			response.content = jsonSerialize( {
				"jsonrpc": "2.0",
				"error": {
					"code": MCPServer::errorCode( "INVALID_REQUEST" ),
					"message": "Request body too large. Maximum allowed: #maxBodySize# bytes"
				},
				"id": ""
			} )
			return response
		}

		// Enhanced CORS handling with wildcard support
		var headers = getHTTPRequestData( false ).headers
		var requestOrigin = headers[ "Origin" ] ?: ""

		// Check if origin is allowed
		if ( len( requestOrigin ) && targetServer.isCorsAllowed( requestOrigin ) ) {
			response.headers[ "Access-Control-Allow-Origin" ] = requestOrigin
			response.headers[ "Vary" ] = "Origin"
		} else if ( targetServer.getCorsAllowedOrigins().contains( "*" ) ) {
			// Wildcard "*" allows all origins
			response.headers[ "Access-Control-Allow-Origin" ] = "*"
		}

		// Handle CORS preflight (bypass callbacks for preflight)
		if ( arguments.requestMethod == "OPTIONS" ) {
			return handleCORSPreflight( response, targetServer )
		}

		// Verify basic authentication if configured
		if ( targetServer.hasBasicAuth() ) {
			var authHeader = headers[ "Authorization" ] ?: ""
			if ( !targetServer.verifyBasicAuth( authHeader ) ) {
				// Log failed authentication attempt
				static.mcpLogger.warn( "MCP basic auth failed for server: #arguments.serverName#" )
				// Return 401 Unauthorized
				response.statusCode = 401
				response.headers[ "WWW-Authenticate" ] = 'Basic realm="MCP Server"'
				response.content = jsonSerialize( {
					"jsonrpc": "2.0",
					"error": {
						"code": MCPServer::errorCode( "INVALID_REQUEST" ),
						"message": "Unauthorized: Invalid credentials"
					},
					"id": ""
				} )
				return response
			}
		}

		// Verify API key if provider configured
		if ( targetServer.hasApiKeyProvider() ) {
			var apiKey = ""
			var authHeader = headers[ "Authorization" ] ?: ""

			// Extract API key from X-API-Key header or Bearer token
			if ( headers.keyExists( "X-API-Key" ) ) {
				apiKey = headers[ "X-API-Key" ]
			} else if ( authHeader.findNoCase( "Bearer " ) ) {
				apiKey = authHeader.replaceNoCase( "Bearer ", "" ).trim()
			}

			if ( !len( apiKey ) || !targetServer.verifyApiKey( apiKey, requestData ) ) {
				// Log failed API key attempt
				static.mcpLogger.warn( "MCP API key validation failed for server: #arguments.serverName#" )
				// Return 401 Unauthorized
				response.statusCode = 401
				response.content = jsonSerialize( {
					"jsonrpc": "2.0",
					"error": {
						"code": MCPServer::errorCode( "INVALID_REQUEST" ),
						"message": "Unauthorized: Invalid API key"
					},
					"id": ""
				} )
				return response
			}
		}

		// Announce MCP request
		BoxAnnounce( "onMCPRequest", {
			server: targetServer,
			requestData: requestData,
			serverName: arguments.serverName
		} )

		// Execute onRequest callback if defined (for authentication/inspection)
		var onRequestCallback = targetServer.getOnRequest();
		if ( isClosure( onRequestCallback ) ) {
			try {
				requestData = onRequestCallback( requestData );
			} catch ( any e ) {
				// Log it
				static.mcpLogger.error( "MCP onRequest callback error: #e.message#" );
				// Authentication or validation failure - return error response
				response.statusCode = 401;
				response.content = jsonSerialize( {
					"jsonrpc": "2.0",
					"error": {
						"code": MCPServer::errorCode( "INVALID_REQUEST" ),
						"message": e.message ?: "Request rejected by onRequest callback"
					},
					"id": ""
				} );
				return response;
			}
		}

		// Handle GET requests for discovery
		if ( arguments.requestMethod == "GET" ) {
			response = handleDiscovery( targetServer, response, arguments.urlParams );
		}
		// Handle POST requests for JSON-RPC
		else if ( arguments.requestMethod == "POST" ) {
			response = handleJSONRPC( targetServer, response, arguments.requestBody, arguments.acceptHeader );
		}
		// Method not allowed
		else {
			response = handleMethodNotAllowed( response );
		}

		// Execute onResponse callback if defined (for transformation/logging)
		var onResponseCallback = targetServer.getOnResponse();
		if ( isClosure( onResponseCallback ) ) {
			try {
				response = onResponseCallback( response, requestData );
			} catch ( any e ) {
				// Log error but don't fail the response
				static.mcpLogger.error( "MCP onResponse callback error: #e.message#" );
			}
		}

		// Announce MCP response
		BoxAnnounce( "onMCPResponse", {
			server: targetServer,
			response: response,
			requestData: requestData,
			serverName: arguments.serverName
		} )

		return response;
	}

	/**
	 * Handle CORS preflight requests
	 *
	 * @response The response struct to populate
	 * @mcpServer The MCP server instance for CORS configuration
	 *
	 * @return The populated response struct
	 */
	private static  struct function handleCORSPreflight( required struct response, required any mcpServer ) {
		arguments.response.headers[ "Access-Control-Allow-Methods" ] = "POST, GET, OPTIONS";
		arguments.response.headers[ "Access-Control-Allow-Headers" ] = "Content-Type, Authorization, X-API-Key";
		arguments.response.headers[ "Access-Control-Max-Age" ] = "86400";

		// Add security headers to preflight response
		arguments.response.headers[ "X-Content-Type-Options" ] = "nosniff";
		arguments.response.headers[ "X-Frame-Options" ] = "DENY";
		arguments.response.headers[ "Referrer-Policy" ] = "strict-origin-when-cross-origin";

		arguments.response.content = "";
		return arguments.response;
	}	/**
	 * Handle GET requests for server discovery
	 *
	 * @server The MCP server instance
	 * @response The response struct to populate
	 * @urlParams URL parameters
	 *
	 * @return The populated response struct
	 */
	private static  struct function handleDiscovery( required any server, required struct response, struct urlParams = {} ) {
		arguments.response.content = {
			"jsonrpc": "2.0",
			"result": {
				"protocolVersion": static.DEFAULT_MCP_PROTOCOL_VERSION,
				"capabilities": arguments.server.getCapabilities(),
				"serverInfo": arguments.server.getServerInfo()
			},
			"id": arguments.urlParams.id ?: javacast( "null", "" )
		}.toJson()

		return arguments.response;
	}

	/**
	 * Handle POST requests for JSON-RPC
	 *
	 * @server The MCP server instance
	 * @response The response struct to populate
	 * @requestBody The request body
	 * @acceptHeader The Accept header value
	 *
	 * @return The populated response struct
	 */
	private static  struct function handleJSONRPC(
		required any server,
		required struct response,
		required string requestBody,
		string acceptHeader = "application/json"
	) {
		try {
			// Determine if SSE format is requested
			var useSSE = arguments.acceptHeader contains "text/event-stream";

			// Process the MCP request
			var mcpResponse = arguments.server.handleRequest( arguments.requestBody );

			// Format response
			if ( useSSE ) {
				arguments.response.contentType = "text/event-stream";
				arguments.response.headers[ "Cache-Control" ] = "no-cache";
				arguments.response.headers[ "Connection" ] = "keep-alive";
				arguments.response.content = "event: message" & chr( 10 ) & "data: " & jsonSerialize( mcpResponse ) & chr( 10 ) & chr( 10 );
			} else {
				arguments.response.content = jsonSerialize( mcpResponse );
			}
		} catch ( any e ) {
			// Log it
			static.mcpLogger.error( "MCP JSON-RPC processing error: #e.message#" );
			// Return JSON-RPC error response
			var errorResponse = {
				"jsonrpc": "2.0",
				"error": {
					"code": MCPServer::errorCode( "PARSE_ERROR" ),
					"message": "Parse error: " & e.message
				},
				"id": ""
			};
			arguments.response.content = jsonSerialize( errorResponse );
		}

		return arguments.response;
	}

	/**
	 * Handle unsupported HTTP methods
	 *
	 * @response The response struct to populate
	 *
	 * @return The populated response struct
	 */
	private static struct function handleMethodNotAllowed( required struct response ) {
		arguments.response.statusCode = 405;

		var errorResponse = {
			"jsonrpc": "2.0",
			"error": {
				"code": MCPServer::errorCode( "INVALID_REQUEST" ),
				"message": "Method not allowed. Use POST for JSON-RPC requests or GET for discovery."
			},
			"id": ""
		};

		arguments.response.content = jsonSerialize( errorResponse );
		return arguments.response;
	}

}
