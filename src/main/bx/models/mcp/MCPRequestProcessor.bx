/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * MCP Request Processor
 *
 * Handles incoming HTTP requests for the MCP server endpoint.
 * This class encapsulates all request processing logic, including:
 * - CORS handling
 * - Request validation
 * - Response formatting (JSON and SSE)
 * - Error handling
 */
import bxModules.bxai.models.mcp.MCPServer
class {

	/**
	 * Static logger for MCP operations
	 */
	static {
		mcpLogger = getBoxRuntime().getLoggingService().getLogger( "mcp" )
        DEFAULT_SERVER_NAME = "default"
	}

	/**
	 * Process an incoming MCP HTTP request
	 *
	 * @serverName The name of the MCP server to use
	 * @requestMethod The HTTP request method (GET, POST, OPTIONS)
	 * @requestBody The request body content (for POST requests)
	 * @acceptHeader The Accept header value
	 * @urlParams URL parameters struct
	 *
	 * @return Struct containing response data: { content, contentType, headers, statusCode }
	 */
	static struct function process(
		string serverName = static.DEFAULT_SERVER_NAME,
		required string requestMethod,
		string requestBody = "",
		string acceptHeader = "application/json",
		struct urlParams = {}
	) {
		var targetServer = mcpServer( arguments.serverName );
		var corsOrigin = targetServer.getCors();
		var response = {
			"content": "",
			"contentType": "application/json",
			"headers": {},
			"statusCode": 200
		};

		// Build request data for callbacks
		var requestData = {
			"serverName": arguments.serverName,
			"method": arguments.requestMethod,
			"body": arguments.requestBody,
			"acceptHeader": arguments.acceptHeader,
			"urlParams": arguments.urlParams
		};

		// Only add CORS header if cors is configured (secure by default)
		if ( len( corsOrigin ) > 0 ) {
			response.headers[ "Access-Control-Allow-Origin" ] = corsOrigin;
		}

		// Handle CORS preflight (bypass callbacks for preflight)
		if ( arguments.requestMethod == "OPTIONS" ) {
			return handleCORSPreflight( response );
		}

		// Announce MCP request
		BoxAnnounce( "onMCPRequest", {
			server: targetServer,
			requestData: requestData,
			serverName: arguments.serverName
		} )
		
		// Execute onRequest callback if defined (for authentication/inspection)
		var onRequestCallback = targetServer.getOnRequest();
		if ( isClosure( onRequestCallback ) ) {
			try {
				requestData = onRequestCallback( requestData );
			} catch ( any e ) {
				// Log it
				static.mcpLogger.error( "MCP onRequest callback error: #e.message#" );
				// Authentication or validation failure - return error response
				response.statusCode = 401;
				response.content = jsonSerialize( {
					"jsonrpc": "2.0",
					"error": {
						"code": MCPServer.RPC_ERROR_CODES.INVALID_REQUEST,
						"message": e.message ?: "Request rejected by onRequest callback"
					},
					"id": ""
				} );
				return response;
			}
		}

		// Handle GET requests for discovery
		if ( arguments.requestMethod == "GET" ) {
			response = handleDiscovery( targetServer, response, arguments.urlParams );
		}
		// Handle POST requests for JSON-RPC
		else if ( arguments.requestMethod == "POST" ) {
			response = handleJSONRPC( targetServer, response, arguments.requestBody, arguments.acceptHeader );
		}
		// Method not allowed
		else {
			response = handleMethodNotAllowed( response );
		}

		// Execute onResponse callback if defined (for transformation/logging)
		var onResponseCallback = targetServer.getOnResponse();
		if ( isClosure( onResponseCallback ) ) {
			try {
				response = onResponseCallback( response, requestData );
			} catch ( any e ) {
				// Log error but don't fail the response
				static.mcpLogger.error( "MCP onResponse callback error: #e.message#" );
			}
		}
		
		// Announce MCP response
		BoxAnnounce( "onMCPResponse", {
			server: targetServer,
			response: response,
			requestData: requestData,
			serverName: arguments.serverName
		} )

		return response;
	}

	/**
	 * Handle CORS preflight requests
	 *
	 * @response The response struct to populate
	 *
	 * @return The populated response struct
	 */
	private static  struct function handleCORSPreflight( required struct response ) {
		arguments.response.headers[ "Access-Control-Allow-Methods" ] = "POST, GET, OPTIONS";
		arguments.response.headers[ "Access-Control-Allow-Headers" ] = "Content-Type, Authorization";
		arguments.response.headers[ "Access-Control-Max-Age" ] = "86400";
		arguments.response.content = "";
		return arguments.response;
	}

	/**
	 * Handle GET requests for server discovery
	 *
	 * @server The MCP server instance
	 * @response The response struct to populate
	 * @urlParams URL parameters
	 *
	 * @return The populated response struct
	 */
	private static  struct function handleDiscovery( required any server, required struct response, struct urlParams = {} ) {
		var discoveryResponse = {
			"jsonrpc": "2.0",
			"result": {
				"protocolVersion": "2024-11-05",
				"capabilities": arguments.server.getCapabilities(),
				"serverInfo": arguments.server.getServerInfo()
			},
			"id": arguments.urlParams.id ?: javacast( "null", "" )
		};

		arguments.response.content = jsonSerialize( discoveryResponse );
		return arguments.response;
	}

	/**
	 * Handle POST requests for JSON-RPC
	 *
	 * @server The MCP server instance
	 * @response The response struct to populate
	 * @requestBody The request body
	 * @acceptHeader The Accept header value
	 *
	 * @return The populated response struct
	 */
	private static  struct function handleJSONRPC(
		required any server,
		required struct response,
		required string requestBody,
		string acceptHeader = "application/json"
	) {
		try {
			// Determine if SSE format is requested
			var useSSE = arguments.acceptHeader contains "text/event-stream";

			// Process the MCP request
			var mcpResponse = arguments.server.handleRequest( arguments.requestBody );

			// Format response
			if ( useSSE ) {
				arguments.response.contentType = "text/event-stream";
				arguments.response.headers[ "Cache-Control" ] = "no-cache";
				arguments.response.headers[ "Connection" ] = "keep-alive";
				arguments.response.content = "event: message" & chr( 10 ) & "data: " & jsonSerialize( mcpResponse ) & chr( 10 ) & chr( 10 );
			} else {
				arguments.response.content = jsonSerialize( mcpResponse );
			}
		} catch ( any e ) {
			// Log it
			static.mcpLogger.error( "MCP JSON-RPC processing error: #e.message#" );
			// Return JSON-RPC error response
			var errorResponse = {
				"jsonrpc": "2.0",
				"error": {
					"code": MCPServer.RPC_ERROR_CODES.PARSE_ERROR,
					"message": "Parse error: " & e.message
				},
				"id": ""
			};
			arguments.response.content = jsonSerialize( errorResponse );
		}

		return arguments.response;
	}

	/**
	 * Handle unsupported HTTP methods
	 *
	 * @response The response struct to populate
	 *
	 * @return The populated response struct
	 */
	private static struct function handleMethodNotAllowed( required struct response ) {
		arguments.response.statusCode = 405;

		var errorResponse = {
			"jsonrpc": "2.0",
			"error": {
				"code": MCPServer.RPC_ERROR_CODES.INVALID_REQUEST,
				"message": "Method not allowed. Use POST for JSON-RPC requests or GET for discovery."
			},
			"id": ""
		};

		arguments.response.content = jsonSerialize( errorResponse );
		return arguments.response;
	}

}
