/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * AI Agent - An autonomous entity that can reason, use tools, and maintain memory
 *
 * Inspired by LangChain agents but "Boxified" for simplicity and productivity.
 * Agents can execute tasks, use tools, maintain conversation memory, and be chained in pipelines.
 */
import bxModules.bxai.models.runnables.*;

class extends="AiBaseRunnable" {

	/**
	 * The agent's name
	 */
	property name="agentName" type="string" default="";

	/**
	 * The agent's description
	 */
	property name="description" type="string" default="";

	/**
	 * System instructions for the agent
	 */
	property name="instructions" type="string" default="";

	/**
	 * The AI model to use for this agent
	 */
	property name="aiModel" type="AiModel";

	/**
	 * Tools available to the agent to use.
	 * It will also use any tools bound to the aiModel.
	 */
	property name="tools" type="array" default=[];

	/**
	 * Memory instances (array of IAiMemory)
	 */
	property name="memories" type="array" default=[];

	/**
	 * Model parameters to use by default
	 */
	property name="params" type="struct" default={};

	/**
	 * Agent options to use by default
	 */
	property name="options" type="struct" default={};

	static {
		DEFAULT_AGENT_NAME = "BxAi";
	}

	/**
	 * Constructor
	 *
	 * @name The agent's name
	 * @description The agent's description
	 * @instructions The agent's instructions
	 * @model The AI model to use, defaults to the default BoxLang AI model
	 * @memory The memory instance or array of memories, defaults to a simple in-memory store
	 * @tools Array of tools for the agent
	 * @params Default model parameters
	 * @options Default agent options
	 */
	function init(
		string name = static.DEFAULT_AGENT_NAME,
		string description = "My BoxLang AI Agent",
		string instructions = "",
		AiModel model = aiModel(),
		any memory = aiMemory(),
		array tools = [],
		struct params = {},
		struct options = {}
	) {
		variables.description = arguments.description;
		variables.instructions = arguments.instructions;
		variables.aiModel = arguments.model.addTools( arguments.tools );
		variables.tools = arguments.tools;
		variables.params = arguments.params;
		variables.options = arguments.options;

		// param the options return format to "single"
		param variables.options.returnFormat = "single";

		// If the agent name is empty, use the default
		if ( arguments.name.len() == 0 ) {
			arguments.name = static.DEFAULT_AGENT_NAME;
		}

		// Set internal name
		setName( arguments.name );

		// Handle memory - can be single or array, or create default simple memory
		if ( isArray( arguments.memory ) ) {
			variables.memories = arguments.memory;
		} else {
			variables.memories = [ arguments.memory ];
		}

		return this;
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * IAiRunnable Interface Implementation
	 * ---------------------------------------------------------------------------------------------------------
	 */

	/**
	 * Execute the agent with a task/prompt
	 *
	 * @input The task or question for the agent
	 * @params Runtime parameters to override
	 * @options Runtime options to override. Supported options:
	 *          - returnFormat: "single" (default), "all", or "raw"
	 *            - single: Returns just the assistant's content string
	 *            - all: Returns all messages (handled by service)
	 *            - raw: Returns the full provider response structure
	 *
	 * @return The agent's response (format depends on returnFormat option)
	 */
	public any function run( any input = "", struct params = {}, struct options = {} ) {
		// Create the user message
		var userMessage = isStruct( arguments.input ) && arguments.input.keyExists( "content" )
			? arguments.input
			: { role: "user", content: toString( arguments.input ) };

		// Build complete message set
		var messages = [];
		// Build system message from instructions and description
		var systemMessage = buildSystemMessage();
		if ( systemMessage.len() > 0 ) {
			messages.append( { role: "system", content: systemMessage } );
		}
		// Load memory messages
		messages.append( loadMemoryMessages(), true );
		// Add user message
		messages.append( userMessage );

		// Merge parameters
		var effectiveParams = variables.params.append( arguments.params );

		// Merge options (including returnFormat)
		var effectiveOptions = variables.options.append( arguments.options );

		// Announce before execution
		BoxAnnounce( "beforeAIAgentRun", {
			agent: this,
			input: arguments.input,
			messages: messages,
			params: effectiveParams,
			options: effectiveOptions
		} );

		// Execute via model - service handles returnFormat and returns formatted result
		var response = variables.aiModel.run( messages, effectiveParams, effectiveOptions );

		// Store in memory (handles all response formats)
		storeInMemory( userMessage, response );

		// Announce after execution
		BoxAnnounce( "afterAIAgentRun", {
			agent: this,
			response: response
		} );

		return response;
	}

	/**
	 * Stream the agent's response
	 *
	 * @onChunk Callback for each chunk
	 * @input The task or question
	 * @params Runtime parameters
	 * @options Runtime options
	 */
	public void function stream(
		required function onChunk,
		any input = "",
		struct params = {},
		struct options = {}
	) {
		// Build system message
		var systemMessage = buildSystemMessage();

		// Load memory
		var memoryMessages = loadMemoryMessages();

		// Create user message
		var userMessage = isStruct( arguments.input ) && arguments.input.keyExists( "content" )
			? arguments.input
			: { role: "user", content: toString( arguments.input ) };

		// Build messages
		var messages = [];
		if ( systemMessage.len() > 0 ) {
			messages.append( { role: "system", content: systemMessage } );
		}
		messages.append( memoryMessages, true );
		messages.append( userMessage );

		// Merge parameters
		var effectiveParams = variables.params.append( arguments.params );

		// Merge options
		var effectiveOptions = variables.options.append( arguments.options );

		// Store accumulated response for memory
		var accumulated = "";
		var wrappedCallback = function( chunk ) {
			// Accumulate content
			var content = chunk.choices?.first()?.delta?.content ?: "";
			accumulated &= content;

			// Call user callback
			arguments.onChunk( chunk );
		};

		// Stream via model (tools handled by model/service)
		variables.aiModel.stream( wrappedCallback, messages, effectiveParams, effectiveOptions );

		// Store in memory after streaming completes
		var assistantMessage = { role: "assistant", content: accumulated };
		storeInMemory( userMessage, assistantMessage );
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * Memory Methods
	 * ---------------------------------------------------------------------------------------------------------
	 */

	 /**
	 * Add another memory to the agent
	 *
	 * @memory The memory instance to add
	 *
	 * @return this for chaining
	 */
	AiAgent function addMemory( required IAiMemory memory ) {
		variables.memories.append( arguments.memory );
		return this;
	}

	/**
	 * Set a single memory (replaces existing) with a single one
	 *
	 * @memory The memory instance
	 *
	 * @return this for chaining
	 */
	function setMemory( required IAiMemory memory ) {
		variables.memories = [ arguments.memory ];
		return this;
	}

	/**
	 * Clear all registered memories
	 *
	 * @return this for chaining
	 */
	function clearMemory() {
		variables.memories.each( .clear() );
		return this;
	}

	/**
	 * Get all messages from all memories
	 *
	 * @return Array of all messages
	 */
	array function getMemoryMessages() {
		return loadMemoryMessages();
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * Configuration Methods
	 * ---------------------------------------------------------------------------------------------------------
	 */

	 /**
	 * Set the agent's name
	 *
	 * @name The agent's name
	 *
	 * @return this for chaining
	 */
	AiAgent function setName( required string name ) {
		variables.agentName = arguments.name;
		variables.name = "AiAgent-" & arguments.name;
		return this;
	}

	/**
	 * Set the AI model for the agent
	 *
	 * @model The AI model to use
	 *
	 * @return this for chaining
	 */
	AiAgent function setModel( required AiModel model ) {
		variables.aiModel = arguments.model.addTools( variables.tools );
		return this;
	}

	/**
	 * Set the tools for the agent (replaces existing tools)
	 *
	 * @tools Array of tools
	 *
	 * @return this for chaining
	 */
	AiAgent function setTools( required array tools ) {
		variables.tools = arguments.tools;
		variables.aiModel.bindTools( arguments.tools );
		return this;
	}

	/**
	 * Add a tool to the agent
	 *
	 * @tool The tool to add
	 *
	 * @return this for chaining
	 */
	AiAgent function addTool( required ITool tool ) {
		variables.tools.append( arguments.tool );
		return this;
	}

	/**
	 * Set a single parameter
	 *
	 * @key Parameter name
	 * @value Parameter value
	 *
	 * @return this for chaining
	 */
	function setParam( required string key, required any value ) {
		variables.params[ arguments.key ] = arguments.value;
		return this;
	}

	/**
	 * Get agent configuration as a struct
	 *
	 * @return Struct of agent configuration
	 */
	struct function getConfig() {
		return {
			"name": variables.agentName,
			"description": variables.description,
			"instructions": variables.instructions,
			"model": variables.aiModel.getConfig(),
			"toolCount": variables.tools.len(),
			"memoryCount": variables.memories.len(),
			"memories": variables.memories.map( mem => mem.getSummary() ),
			"params": variables.params,
			"options": variables.options
		};
	}

	// ==================== PRIVATE METHODS ====================

	/**
	 * Build the system message from instructions and description
	 */
	private string function buildSystemMessage() {
		var parts = [];

		if ( variables.description.len() > 0 ) {
			parts.append( "Role: " & variables.description );
		}

		if ( variables.instructions.len() > 0 ) {
			parts.append( variables.instructions );
		}

		// Add default agent instructions if none provided
		if ( parts.isEmpty() ) {
			parts.append( "You are a helpful AI assistant. Use the available tools when needed to accomplish tasks." );
		}

		return parts.toList( char( 10 ) & char( 10 ) );
	}

	/**
	 * Load messages from all memories
	 */
	private array function loadMemoryMessages() {
		var allMessages = [];

		variables.memories.each( mem => {
			allMessages.append( mem.getAll(), true );
		} );

		return allMessages;
	}

	/**
	 * Store messages in all memories
	 *
	 * @userMessage The user message struct
	 * @response The assistant response (string or struct)
	 *
	 * @return void
	 */
	private void function storeInMemory( required struct userMessage, required any response ) {
		// No memories, nothing to do
		if ( variables.memories.isEmpty() ) {
			return;
		}

		// Add user message to all memories
		variables.memories.each( .add( userMessage ) );

		// Extract assistant message from response
		var assistantContent = "";
		if ( isStruct( arguments.response ) ) {
			// Handle structured response
			if ( arguments.response.keyExists( "choices" ) && !arguments.response.choices.isEmpty() ) {
				assistantContent = arguments.response.choices[  1  ].message?.content ?: "";
			} else if ( arguments.response.keyExists( "content" ) ) {
				assistantContent = arguments.response.content;
			}
		} else {
			assistantContent = toString( arguments.response );
		}

		// Add assistant message
		if ( assistantContent.len() > 0 ) {
			variables.memories.each( mem => mem.add({
				role: "assistant",
				content: assistantContent
			}) );
		}
	}

}
