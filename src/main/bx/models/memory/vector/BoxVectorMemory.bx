/**
 * BoxLang In-Memory Vector Memory Implementation
 *
 * A simple vector-based memory store for testing and development purposes.
 * Stores embeddings in memory using BoxLang arrays and provides similarity search.
 *
 * @singleton
 */
class extends="BaseVectorMemory" {

	/**
	 * Constructor
	 */
	function init() {
		super.init();

		// In-memory storage for vectors and metadata
		variables.vectors    = []; // array of embeddings
		variables.metadata   = []; // array of structs
		variables.ids        = []; // array of ids
		variables.nextId     = 1;
		variables.configured = false;

		// 0 = not set yet, first insert defines it
		variables.dimension  = 0;

		return this;
	}

	/**
	 * Configure the memory store
	 *
	 * @options Struct of configuration options (not needed for in-memory, but here for interface consistency)
	 */
	function configure( struct options = {} ) {
		// could accept dimension in options later:
		// if ( options.keyExists( "dimension" ) ) variables.dimension = options.dimension;
		variables.configured = true;
		return this;
	}

	/**
	 * Ensure the collection exists (no-op for in-memory storage)
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function ensureCollection() {
		// No-op: In-memory storage doesn't require explicit collection creation
		return this;
	}

	/**
	 * Add a vector with metadata to memory
	 *
	 * @vector   Array of numbers representing the embedding vector
	 * @metadata Struct of metadata associated with the vector
	 * @id       Optional custom ID, auto-generated if not provided
	 *
	 * @return string The ID of the stored vector
	 */
	function add( required array vector, struct metadata = {}, string id = "" ) {
		if ( !variables.configured ) {
			configure();
		}

		// Set dimension on first add
		if ( variables.dimension == 0 ) {
			variables.dimension = arguments.vector.len();
		} else if ( arguments.vector.len() != variables.dimension ) {
			throw(
				type    = "VectorDimensionMismatch",
				message = "All vectors must have the same dimensions",
				detail  = "Expected #variables.dimension#, got #arguments.vector.len()#"
			);
		}

		// Generate ID if not provided
		var vectorId = len( arguments.id ) ? arguments.id : "vec_#variables.nextId++#";

		// Store vector and metadata
		variables.vectors.append( arguments.vector );
		variables.metadata.append( arguments.metadata );
		variables.ids.append( vectorId );

		return vectorId;
	}

	/**
	 * Search for similar vectors using cosine similarity
	 *
	 * @vector    Array of numbers representing the query vector
	 * @limit     Number of results to return (default: 5)
	 * @threshold Minimum similarity score threshold (default: 0.0)
	 *
	 * @return Array of structs containing { id, score, metadata, vector }
	 */
	function search( required array vector, numeric limit = 5, numeric threshold = 0.0 ) {
		// No data
		if ( variables.vectors.len() == 0 ) {
			return [];
		}

		// Dim check
		if ( variables.dimension > 0 && arguments.vector.len() != variables.dimension ) {
			throw(
				type    = "VectorDimensionMismatch",
				message = "Query vector must have the same dimensions as stored vectors",
				detail  = "Expected #variables.dimension#, got #arguments.vector.len()#"
			);
		}

		var results = [];

		// Calculate similarity for each stored vector
		for ( var i = 1; i <= variables.vectors.len(); i++ ) {
			var similarity = cosineSimilarity( arguments.vector, variables.vectors[ i ] );

			if ( similarity >= arguments.threshold ) {
				results.append({
					id      : variables.ids[ i ],
					score   : similarity,
					metadata: variables.metadata[ i ],
					vector  : variables.vectors[ i ]
				});
			}
		}

		// Sort by similarity score (descending)
		results.sort( function( a, b ) {
			return b.score - a.score;
		} );

		// Return top N results
		if ( results.len() > arguments.limit ) {
			results = results.slice( 1, arguments.limit );
		}

		return results;
	}

	/**
	 * Get a vector by ID
	 *
	 * @id The ID of the vector to retrieve
	 *
	 * @return Struct with { id, metadata, vector } or empty struct if not found
	 */
	function get( required string id ) {
		var index = variables.ids.findNoCase( arguments.id );

		if ( index > 0 ) {
			return {
				id      : variables.ids[ index ],
				metadata: variables.metadata[ index ],
				vector  : variables.vectors[ index ]
			};
		}

		return {};
	}

	/**
	 * Delete a vector by ID
	 *
	 * @id The ID of the vector to delete
	 *
	 * @return boolean True if deleted, false if not found
	 */
	function delete( required string id ) {
		var index = variables.ids.findNoCase( arguments.id );

		if ( index > 0 ) {
			variables.vectors.deleteAt( index );
			variables.metadata.deleteAt( index );
			variables.ids.deleteAt( index );
			return true;
		}

		return false;
	}

	/**
	 * Clear all vectors from memory
	 */
	function clear() {
		variables.vectors   = [];
		variables.metadata  = [];
		variables.ids       = [];
		variables.nextId    = 1;
		variables.dimension = 0;
		return this;
	}

	/**
	 * Get the count of stored vectors
	 */
	function count() {
		return variables.vectors.len();
	}

	/**
	 * Calculate cosine similarity between two vectors
	 *
	 * @vector1 First vector
	 * @vector2 Second vector
	 *
	 * @return numeric Similarity score between -1 and 1
	 */
	private function cosineSimilarity( required array vector1, required array vector2 ) {
		if ( arguments.vector1.len() != arguments.vector2.len() ) {
			throw(
				type    = "VectorDimensionMismatch",
				message = "Vectors must have the same dimensions",
				detail  = "Vector1 has #arguments.vector1.len()# dimensions, Vector2 has #arguments.vector2.len()# dimensions"
			);
		}

		var dotProduct = 0;
		var magnitude1 = 0;
		var magnitude2 = 0;

		for ( var i = 1; i <= arguments.vector1.len(); i++ ) {
			dotProduct += arguments.vector1[ i ] * arguments.vector2[ i ];
			magnitude1 += arguments.vector1[ i ] * arguments.vector1[ i ];
			magnitude2 += arguments.vector2[ i ] * arguments.vector2[ i ];
		}

		magnitude1 = sqr( magnitude1 );
		magnitude2 = sqr( magnitude2 );

		if ( magnitude1 == 0 || magnitude2 == 0 ) {
			return 0;
		}

		return dotProduct / ( magnitude1 * magnitude2 );
	}

	/**
	 * Get the name of this memory provider
	 */
	function getName() {
		return "BoxVectorMemory";
	}

	/**
	 * ------------------------------------------------------------------------------
	 * ABSTRACT METHOD IMPLEMENTATIONS (BaseVectorMemory interface)
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Store a document in the vector database
	 *
	 * @id Document ID
	 * @text Document text
	 * @embedding Vector embedding
	 * @metadata Document metadata
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function storeDocument(
		required string id,
		required string text,
		required array embedding,
		required struct metadata
	) {
		// Use the add() method internally
		add(
			vector   = arguments.embedding,
			metadata = arguments.metadata.append( { text: arguments.text } ),
			id       = arguments.id
		);
		return this;
	}

	/**
	 * Search by vector embedding
	 *
	 * @embedding Vector to search with
	 * @limit Max results
	 * @filter Metadata filter (not implemented for in-memory)
	 *
	 * @return Array of results with { id, score, metadata, text }
	 */
	array function searchByVector(
		required array embedding,
		required numeric limit,
		required struct filter
	) {
		// Use search() method and transform results to match interface
		var results = search(
			vector = arguments.embedding,
			limit  = arguments.limit
		);

		// Transform to expected format
		return results.map( ( result ) => {
			return {
				id       : result.id,
				score    : result.score,
				metadata : result.metadata,
				text     : result.metadata.text ?: ""
			};
		} );
	}

	/**
	 * Get all documents from collection
	 *
	 * @return Array of documents
	 */
	array function getAllDocuments() {
		var docs = [];
		for ( var i = 1; i <= variables.ids.len(); i++ ) {
			docs.append({
				id       : variables.ids[ i ],
				metadata : variables.metadata[ i ],
				text     : variables.metadata[ i ].text ?: "",
				vector   : variables.vectors[ i ]
			});
		}
		return docs;
	}

	/**
	 * Get document by ID
	 *
	 * @id Document ID
	 *
	 * @return Struct document or empty struct
	 */
	struct function getDocumentById( required string id ) {
		var result = get( arguments.id );
		if ( !result.isEmpty() ) {
			result.text = result.metadata.text ?: "";
		}
		return result;
	}

	/**
	 * Delete document by ID
	 *
	 * @id Document ID
	 *
	 * @return Boolean success
	 */
	boolean function deleteDocument( required string id ) {
		return delete( arguments.id );
	}

	/**
	 * Delete documents by filter (not efficiently implemented for in-memory)
	 *
	 * @filter Metadata filter
	 *
	 * @return Numeric count deleted
	 */
	numeric function deleteDocumentsByFilter( required struct filter ) {
		var count = 0;
		// Simple implementation: iterate and check each metadata field
		for ( var i = variables.ids.len(); i >= 1; i-- ) {
			var matches = true;
			for ( var key in arguments.filter ) {
				if ( !variables.metadata[ i ].keyExists( key ) || variables.metadata[ i ][ key ] != arguments.filter[ key ] ) {
					matches = false;
					break;
				}
			}
			if ( matches ) {
				variables.vectors.deleteAt( i );
				variables.metadata.deleteAt( i );
				variables.ids.deleteAt( i );
				count++;
			}
		}
		return count;
	}

	/**
	 * Clear entire collection
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function clearCollection() {
		clear();
		return this;
	}

}