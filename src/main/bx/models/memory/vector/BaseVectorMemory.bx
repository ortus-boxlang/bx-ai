/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * Base abstract class for Vector Memory implementations
 * Provides common functionality for semantic search and embedding generation
 */
abstract class
	extends="bxModules.bxai.models.memory.BaseMemory"
	implements="IVectorMemory" {

	/**
	 * Collection/index/class name for this vector store
	 * Each implementation may have different naming conventions
	 */
	property name="collection" default="";

	/**
	 * Embedding provider (e.g., "openai", "ollama")
	 */
	property name="embeddingProvider" default="";

	/**
	 * Embedding model name
	 */
	property name="embeddingModel" default="";

	/**
	 * Vector dimensions (auto-detected from first embedding if not specified)
	 */
	property name="dimensions" type="numeric" default=0;

	/**
	 * Distance metric: "cosine", "euclidean", "dot_product"
	 */
	property name="metric" type="string" default="#static.DEFAULT_METRIC#";

	/**
	 * Cache configuration for embeddings and query results
	 */
	property name="useCache" type="boolean" default=false;
	property name="cacheName" default="default";
	property name="cacheTimeout" type="numeric";  // empty = defaults to cache provider
	property name="cacheLastAccessTimeout" type="numeric";  // empty = defaults to cache provider
	property name="cacheInstance" type="any";

	static{
		DEFAULT_COLLECTION = "ai_memory"
		DEFAULT_METRIC = "cosine"
		HASH_ALGORITHM = "SHA-256"
		CACHE_EMBEDDINGS_PREFIX = "embedding:"
	}

	/**
	 * Constructor
	 *
	 * @key The unique key for this memory instance, typically a UUID, defaults to random UUID
	 * @collection The collection/index name (default: "ai_memory")
	 */
	function init( string key = createUUID(), string collection = static.DEFAULT_COLLECTION ) {
		super.init( arguments.key );
		variables.collection = arguments.collection;
		return this;
	}

	/**
	 * ------------------------------------------------------------------------------
	 * IAiMemory INTERFACE OVERRIDES
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Configure the vector memory instance
	 *
	 * @config Configuration struct with provider-specific options
	 *
	 * @return IVectorMemory for chaining
	 */
	IAiMemory function configure( required struct config ) {
		super.configure( arguments.config );

		// Extract common vector config
		if ( arguments.config.keyExists( "collection" ) ) {
			variables.collection = arguments.config.collection;
		}
		if ( arguments.config.keyExists( "embeddingProvider" ) ) {
			variables.embeddingProvider = arguments.config.embeddingProvider;
		}
		if ( arguments.config.keyExists( "embeddingModel" ) ) {
			variables.embeddingModel = arguments.config.embeddingModel;
		}
		if ( arguments.config.keyExists( "dimensions" ) ) {
			variables.dimensions = arguments.config.dimensions;
		}
		if ( arguments.config.keyExists( "metric" ) ) {
			variables.metric = arguments.config.metric;
		}

		// Cache configuration
		if ( arguments.config.keyExists( "cache" ) ) {
			variables.useCache = arguments.config.cache;
		}
		if ( arguments.config.keyExists( "cacheName" ) ) {
			variables.cacheName = arguments.config.cacheName;
		}
		if ( arguments.config.keyExists( "cacheTimeout" ) ) {
			variables.cacheTimeout = arguments.config.cacheTimeout;
		}
		if ( arguments.config.keyExists( "cacheLastAccessTimeout" ) ) {
			variables.cacheLastAccessTimeout = arguments.config.cacheLastAccessTimeout;
		}

		// Initialize cache if enabled
		if ( variables.useCache ) {
			variables.cacheInstance = cache( variables.cacheName );
		}

		// Ensure collection exists (provider-specific implementation)
		ensureCollection();

		return this;
	}

	/**
	 * Add a message to this memory
	 * Automatically generates embedding and stores in vector database
	 *
	 * @message The message to add (string, struct with id/text/metadata, or AiMessage)
	 *
	 * @return IVectorMemory for chaining
	 */
	IAiMemory function add( required any message ) {
		var text = normalizeMessageText( arguments.message );
		var metadata = extractMetadata( arguments.message );

		// Check if message struct contains an explicit id
		var id = "";
		if ( isStruct( arguments.message ) && arguments.message.keyExists( "id" ) ) {
			id = arguments.message.id;
		} else {
			id = generateId( text );
		}

		return addWithId( id, text, metadata );
	}

	/**
	 * Get all messages (delegates to provider implementation)
	 * For vector stores, this typically returns recent messages or all with limit
	 *
	 * @return Array of message structs
	 */
	array function getAll() {
		// Provider-specific implementation
		return getAllDocuments();
	}

	/**
	 * Clear all messages from this memory (delegates to collection deletion)
	 *
	 * @return IVectorMemory for chaining
	 */
	IAiMemory function clear() {
		clearCollection();
		return this;
	}

	/**
	 * ------------------------------------------------------------------------------
	 * IVectorMemory INTERFACE IMPLEMENTATIONS
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Get relevant messages based on semantic similarity
	 * Embedding generation is cached (if enabled), but search results are always fresh
	 *
	 * @query The text query to find similar messages for
	 * @limit Maximum number of results to return
	 * @filter Optional metadata filter
	 * @minScore Minimum similarity score threshold
	 *
	 * @return Array of message structs with similarity scores
	 */
	array function getRelevant(
		required string query,
		numeric limit = 5,
		struct filter = {},
		numeric minScore = 0.0
	) {
		// Generate embedding (cached internally if enabled)
		var embedding = generateEmbedding( arguments.query );

		// Search with fresh results (new documents may have been added)
		var results = findSimilar(
			embedding = embedding,
			limit = arguments.limit,
			filter = arguments.filter
		);

		// Filter by minimum score
		return results.filter( ( doc ) => doc.score >= minScore );
	}

	/**
	 * Find similar messages using a pre-computed embedding
	 * Delegates to provider-specific implementation
	 *
	 * @embedding The vector embedding to search with
	 * @limit Maximum number of results to return
	 * @filter Optional metadata filter
	 *
	 * @return Array of message structs with similarity scores
	 */
	array function findSimilar(
		required array embedding,
		numeric limit = 5,
		struct filter = {}
	) {
		// Announce event for observability
		BoxAnnounce( "onVectorSearch", {
			collection: variables.collection,
			limit: arguments.limit,
			hasFilter: !arguments.filter.isEmpty(),
			timestamp: now()
		} );

		// Provider-specific implementation
		return searchByVector( arguments.embedding, arguments.limit, arguments.filter );
	}

	/**
	 * Add a message with explicit ID (upsert behavior)
	 *
	 * @id The unique identifier
	 * @text The text content
	 * @metadata Optional metadata
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function addWithId(
		required string id,
		required string text,
		struct metadata = {}
	) {
		// Generate embedding
		var embedding = generateEmbedding( arguments.text );

		// Store in vector database (provider-specific)
		storeDocument(
			id = arguments.id,
			text = arguments.text,
			embedding = embedding,
			metadata = arguments.metadata
		);

		// Announce event
		BoxAnnounce( "onVectorStore", {
			collection: variables.collection,
			documentId: arguments.id,
			hasMetadata: !arguments.metadata.isEmpty(),
			timestamp: now()
		} );

		return this;
	}

	/**
	 * Seed the vector store with multiple documents
	 * Optimized for batch insertion
	 *
	 * @documents Array of documents (strings or structs)
	 *
	 * @return Struct with results
	 */
	public struct function seed( required array documents ) {
		var results = {
			added: 0,
			failed: 0,
			errors: []
		};

		// Normalize documents
		var normalized = arguments.documents.map( ( doc ) => {
			if ( isSimpleValue( doc ) ) {
				return {
					id: generateId( doc ),
					text: doc,
					metadata: {}
				};
			}
			return {
				id: doc.id ?: generateId( doc.text ),
				text: doc.text,
				metadata: doc.metadata ?: {}
			};
		} );

		// Extract all text for batch embedding
		var texts = normalized.map( ( doc ) => doc.text );

		// Generate embeddings in batch
		var embeddings = generateEmbeddingBatch( texts );

		// Store each document
		normalized.each( ( doc, index ) => {
			try {
				storeDocument(
					id = doc.id,
					text = doc.text,
					embedding = embeddings[ index ],
					metadata = doc.metadata
				);
				results.added++;
			} catch ( any e ) {
				results.failed++;
				results.errors.append({
					id: doc.id,
					error: e.message
				});
			}
		} );

		// Announce batch event
		BoxAnnounce( "onVectorBatchStore", {
			collection: variables.collection,
			added: results.added,
			failed: results.failed,
			timestamp: now()
		} );

		return results;
	}

	/**
	 * Get a document by ID
	 * Delegates to provider implementation
	 *
	 * @id The document ID
	 *
	 * @return Struct with document data or empty struct
	 */
	struct function getById( required string id ) {
		return getDocumentById( arguments.id );
	}

	/**
	 * Remove a document by ID
	 * Delegates to provider implementation
	 *
	 * @id The document ID
	 *
	 * @return Boolean success
	 */
	boolean function remove( required string id ) {
		var success = deleteDocument( arguments.id );

		if ( success ) {
			BoxAnnounce( "onVectorDelete", {
				collection: variables.collection,
				documentId: arguments.id,
				timestamp: now()
			} );
		}

		return success;
	}

	/**
	 * Remove documents by metadata filter
	 * Delegates to provider implementation
	 *
	 * @filter Metadata filter
	 *
	 * @return Numeric count removed
	 */
	numeric function removeWhere( required struct filter ) {
		var count = deleteDocumentsByFilter( arguments.filter );

		BoxAnnounce( "onVectorDeleteBatch", {
			collection: variables.collection,
			count: count,
			timestamp: now()
		} );

		return count;
	}

	/**
	 * ------------------------------------------------------------------------------
	 * IVectorMemory COLLECTION MANAGEMENT (Delegates to concrete implementations)
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Create a new collection/index
	 * Most implementations auto-create on first use, but this allows explicit creation
	 *
	 * @name The collection/index name
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function createCollection( required string name ){
		throw( type="NotImplementedException", message="createCollection() must be implemented by concrete vector memory classes." );
	}

	/**
	 * Check if a collection/index exists
	 *
	 * @name The collection/index name to check
	 *
	 * @return Boolean indicating existence
	 */
	boolean function collectionExists( required string name ){
		throw( type="NotImplementedException", message="collectionExists() must be implemented by concrete vector memory classes." );
	}

	/**
	 * Delete a collection/index and all its documents
	 *
	 * @name The collection/index name to delete
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function deleteCollection( required string name ){
		throw( type="NotImplementedException", message="deleteCollection() must be implemented by concrete vector memory classes." );
	}

	/**
	 * ------------------------------------------------------------------------------
	 * HELPER METHODS
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Generate embedding for a single text using aiEmbed() BIF
	 *
	 * @text The text to embed
	 *
	 * @return Array embedding vector
	 */
	private array function generateEmbedding( required string text ) {
		// Use cache if enabled
		if ( variables.useCache ) {
			var cacheKey = getCacheKey( arguments.text );
			return variables.cacheInstance.getOrSet(
				key = cacheKey,
				produce = () => _generateEmbedding( text ),
				timeout = variables.cacheTimeout,
				lastAccessTimeout = variables.cacheLastAccessTimeout
			);
		}

		// No cache - generate directly
		return _generateEmbedding( arguments.text );
	}

	/**
	 * Generate embedding without cache (internal helper)
	 *
	 * @text The text to embed
	 *
	 * @return Array embedding vector
	 */
	private array function _generateEmbedding( required string text ) {
		// Prep request params
		var params = {};
		if ( len( variables.embeddingModel ) ) {
			params.model = variables.embeddingModel;
		}

		// Prep request options
		var options = {};
		if ( len( variables.embeddingProvider ) ) {
			options.provider = variables.embeddingProvider;
		}

		// Generate embedding
		var embedding = aiEmbed(
			input : arguments.text,
			params : params,
			options : options
		);

		// Auto-detect dimensions from first embedding
		if ( variables.dimensions == 0 ) {
			variables.dimensions = embedding.len();
		}

		return embedding;
	}

	/**
	 * Generate cache key for a given text
	 *
	 * @text The text to generate cache key for
	 *
	 * @return String cache key
	 */
	private string function getCacheKey( required string text ) {
		return static.CACHE_EMBEDDINGS_PREFIX &
			variables.embeddingProvider & ":" &
			variables.embeddingModel & ":" &
			hash( arguments.text, static.HASH_ALGORITHM );
	}

	/**
	 * Generate embeddings for multiple texts in batch
	 *
	 * @texts Array of texts to embed
	 *
	 * @return Array of embedding vectors
	 */
	private array function generateEmbeddingBatch( required array texts ) {
		// Build params
		var params = {};
		if ( len( variables.embeddingModel ) ) {
			params.model = variables.embeddingModel;
		}

		var options = {
			returnFormat: "embeddings"  // Get array of vectors
		};
		if ( len( variables.embeddingProvider ) ) {
			options.provider = variables.embeddingProvider;
		}

		// Generate batch embeddings
		var embeddings = aiEmbed(
			input = arguments.texts,
			params = params,
			options = options
		);

		// Cache each embedding if enabled
		if ( variables.useCache ) {
			arguments.texts.each( ( text, index ) => {
				var cacheKey = getCacheKey( text );
				variables.cacheInstance.set(
					key = cacheKey,
					value = embeddings[ index ],
					timeout = variables.cacheTimeout,
					lastAccessTimeout = variables.cacheLastAccessTimeout
				);
			} );
		}

		return embeddings;
	}

	/**
	 * Generate a unique ID from text content (SHA-256 hash)
	 *
	 * @text The text to generate ID from
	 *
	 * @return String UUID-style ID
	 */
	private string function generateId( required string text ) {
		// Use hash of text + timestamp for uniqueness
		return hash( arguments.text & now().getTime(), static.HASH_ALGORITHM ).left( 32 );
	}

	/**
	 * Normalize message to text string
	 *
	 * @message Message in any format
	 *
	 * @return String text
	 */
	private string function normalizeMessageText( required any message ) {
		if ( isSimpleValue( arguments.message ) ) {
			return arguments.message;
		}
		if ( isStruct( arguments.message ) ) {
			return arguments.message.content ?: arguments.message.text ?: "";
		}
		if ( isObject( arguments.message ) && arguments.message.hasMethod( "getContent" ) ) {
			return arguments.message.getContent();
		}
		return "";
	}

	/**
	 * Extract metadata from message object
	 *
	 * @message Message in any format
	 *
	 * @return Struct metadata
	 */
	private struct function extractMetadata( required any message ) {
		if ( isStruct( arguments.message ) ) {
			// If message has explicit metadata field, use that
			if ( arguments.message.keyExists( "metadata" ) ) {
				return arguments.message.metadata;
			}
			// Otherwise, extract all fields except text/content/id
			var meta = arguments.message.duplicate();
			meta.delete( "content" );
			meta.delete( "text" );
			meta.delete( "id" );
			return meta;
		}
		return {};
	}

	/**
	 * Normalize a given ID to UUID format
	 *
	 * @id The ID to normalize
	 *
	 * @return String normalized UUID
	 */
	private string function normalizeUUID( required string id ) {
		// Quick check - if already formatted, return immediately
		if ( arguments.id.len() == 36 && arguments.id.charAt( 8 ) == "-" ) {
			return arguments.id;
		}

		// Remove dashes
		var cleaned = arguments.id.replace( "-", "", "all" );

		// Validate length
		if ( cleaned.len() != 32 ) {
			return arguments.id;
		}

		// Format using substring (0-indexed, much faster than mid)
		return cleaned.substring( 0, 8 ) & "-" &
			cleaned.substring( 8, 12 ) & "-" &
			cleaned.substring( 12, 16 ) & "-" &
			cleaned.substring( 16, 20 ) & "-" &
			cleaned.substring( 20 );
	}

	/**
	 * ------------------------------------------------------------------------------
	 * ABSTRACT METHODS (Provider-specific implementations)
	 * ------------------------------------------------------------------------------
	 * The following methods must be implemented by concrete vector memory classes
	 */

	/**
	 * Ensure collection/index exists (provider-specific)
	 */
	abstract IVectorMemory function ensureCollection();

	/**
	 * Store a document in the vector database (provider-specific)
	 *
	 * @id Document ID
	 * @text Document text
	 * @embedding Vector embedding
	 * @metadata Document metadata
	 */
	abstract IVectorMemory function storeDocument(
		required string id,
		required string text,
		required array embedding,
		required struct metadata
	);

	/**
	 * Search by vector embedding (provider-specific)
	 *
	 * @embedding Vector to search with
	 * @limit Max results
	 * @filter Metadata filter
	 *
	 * @return Array of results
	 */
	abstract array function searchByVector(
		required array embedding,
		required numeric limit,
		required struct filter
	);

	/**
	 * Get all documents from collection (provider-specific)
	 *
	 * @return Array of documents
	 */
	abstract array function getAllDocuments();

	/**
	 * Get document by ID (provider-specific)
	 *
	 * @id Document ID
	 *
	 * @return Struct document or empty struct
	 */
	abstract struct function getDocumentById( required string id );

	/**
	 * Delete document by ID (provider-specific)
	 *
	 * @id Document ID
	 *
	 * @return Boolean success
	 */
	abstract boolean function deleteDocument( required string id );

	/**
	 * Delete documents by filter (provider-specific)
	 *
	 * @filter Metadata filter
	 *
	 * @return Numeric count deleted
	 */
	abstract numeric function deleteDocumentsByFilter( required struct filter );

	/**
	 * Clear entire collection (provider-specific)
	 */
	abstract IVectorMemory function clearCollection();

}
