/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * PostgreSQL Vector Memory Implementation with pgvector extension
 * Provides vector storage and semantic search using PostgreSQL's pgvector
 * Ideal for enterprise deployments with existing PostgreSQL infrastructure
 */
class extends="BaseVectorMemory" {

	/**
	 * PostgreSQL datasource name
	 */
	property name="datasource" type="string";

	/**
	 * Table name for vector storage
	 */
	property name="table" type="string";

	/**
	 * Distance function: L2, COSINE, or INNER_PRODUCT
	 */
	property name="distanceFunction" type="string";

	/**
	 * Index type: HNSW or IVFFLAT
	 */
	property name="indexType" type="string";

	/**
	 * HNSW index parameters
	 */
	property name="hnswM" type="numeric";
	property name="hnswEfConstruction" type="numeric";

	static {
		// Default configurations
		DEFAULT_DISTANCE_FUNCTION = "COSINE"
		DEFAULT_TABLE = "bx_ai_vectors"
		DEFAULT_INDEX_TYPE = "HNSW"
		DEFAULT_HNSW_M = 16
		DEFAULT_HNSW_EF_CONSTRUCTION = 64
		// Distance operators for pgvector (used in queries)
		DISTANCE_OPERATORS = {
			"L2": "<->",           // Euclidean distance
			"COSINE": "<=>",       // Cosine distance
			"INNER_PRODUCT": "<##>" // Inner product (negative)
		}
		// Operator classes for pgvector indexes (used in CREATE INDEX)
		INDEX_OPS = {
			"L2": "vector_l2_ops",
			"COSINE": "vector_cosine_ops",
			"INNER_PRODUCT": "vector_ip_ops"
		}
		// Index methods
		INDEX_TYPES = {
			"HNSW": "hnsw",
			"IVFFLAT": "ivfflat"
		}
	}

	/**
	 * Configure the PostgreSQL vector memory instance
	 *
	 * @config Configuration struct with Postgres-specific options
	 *
	 * @return PostgresVectorMemory for chaining
	 */
	public any function configure( required struct config ) {
		// Extract Postgres-specific config FIRST
		param arguments.config.datasource = ""
		param arguments.config.table = static.DEFAULT_TABLE
		param arguments.config.distanceFunction = static.DEFAULT_DISTANCE_FUNCTION
		param arguments.config.indexType = static.DEFAULT_INDEX_TYPE
		param arguments.config.hnswM = static.DEFAULT_HNSW_M
		param arguments.config.hnswEfConstruction = static.DEFAULT_HNSW_EF_CONSTRUCTION

		// Validate required config
		if ( !len( arguments.config.datasource ) ) {
			throw(
				type = "PostgresVectorMemory.MissingDatasource",
				message = "Datasource is required for PostgresVectorMemory. Provide it in the config."
			)
		}

		variables.datasource = arguments.config.datasource
		variables.table = arguments.config.table
		variables.distanceFunction = arguments.config.distanceFunction.ucase()
		variables.indexType = arguments.config.indexType.ucase()
		variables.hnswM = arguments.config.hnswM
		variables.hnswEfConstruction = arguments.config.hnswEfConstruction

		// Validate distance function
		if ( !static.DISTANCE_OPERATORS.keyExists( variables.distanceFunction ) ) {
			throw(
				type = "PostgresVectorMemory.InvalidDistanceFunction",
				message = "Invalid distance function: #variables.distanceFunction#. Must be L2, COSINE, or INNER_PRODUCT."
			)
		}

		// Now call parent configure which will call ensureCollection()
		super.configure( arguments.config )

		return this
	}

	/**
	 * ------------------------------------------------------------------------------
	 * ABSTRACT METHOD IMPLEMENTATIONS
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Ensure pgvector extension and table exist
	 */
	IVectorMemory function ensureCollection() {
		// Enable pgvector extension
		ensurePgvectorExtension()

		// Create table if it doesn't exist
		if ( !collectionExists( variables.collection ) ) {
			createCollection( variables.collection )
		}

		return this
	}

	/**
	 * Store a document in PostgreSQL
	 *
	 * @id Document ID
	 * @text Document text
	 * @embedding Vector embedding
	 * @metadata Document metadata
	 */
	IVectorMemory function storeDocument(
		required string id,
		required string text,
		required array embedding,
		required struct metadata
	) {
		// Convert embedding array to pgvector format
		var vectorStr = "[" & arguments.embedding.toList() & "]"

		// Serialize metadata to JSON
		var metadataJson = jsonSerialize( arguments.metadata )

		// Upsert (INSERT ... ON CONFLICT UPDATE)
		queryExecute(
			"INSERT INTO #variables.table# (
				id, text, embedding, metadata, collection, userId, conversationId, created_at, updated_at
			) VALUES (
				:id, :text, CAST(:embedding AS vector), CAST(:metadata AS jsonb), :collection, :userId, :conversationId, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
			)
			ON CONFLICT (id, collection)
			DO UPDATE SET
				text = EXCLUDED.text,
				embedding = EXCLUDED.embedding,
				metadata = EXCLUDED.metadata,
				userId = EXCLUDED.userId,
				conversationId = EXCLUDED.conversationId,
				updated_at = CURRENT_TIMESTAMP",
			{
				id: arguments.id,
				text: arguments.text,
				embedding: vectorStr,
				metadata: metadataJson,
				collection: variables.collection,
				userId: variables.userId,
				conversationId: variables.conversationId
			},
			{ datasource: variables.datasource }
		)

		return this;
	}

	/**
	 * Search by vector embedding in PostgreSQL
	 *
	 * @embedding Vector to search with
	 * @limit Max results
	 * @filter Metadata filter (JSONB query)
	 *
	 * @return Array of results with similarity scores
	 */
	array function searchByVector(
		required array embedding,
		required numeric limit,
		required struct filter
	) {
		var vectorStr = "[" & arguments.embedding.toList() & "]"
		var distanceOp = static.DISTANCE_OPERATORS[ variables.distanceFunction ]

		// Build WHERE clause with collection, userId, conversationId
		var whereClause = "collection = :collection"
		var params = {
			embedding: vectorStr,
			collection: variables.collection,
			limit: { value: arguments.limit, type: "integer" }
		}

		// Add userId filter if set
		if ( len( variables.userId ) ) {
			whereClause &= " AND userId = :userId";
			params.userId = variables.userId;
		}

		// Add conversationId filter if set
		if ( len( variables.conversationId ) ) {
			whereClause &= " AND conversationId = :conversationId";
			params.conversationId = variables.conversationId;
		}

		// Add JSONB metadata filters if provided
		if ( !arguments.filter.isEmpty() ) {
			arguments.filter.each( ( key, value ) => {
				whereClause &= " AND metadata->>'#key#' = :#key#";
				params[ key ] = value;
			} )
		}

		// Execute search with distance calculation
		var result = queryExecute(
			"SELECT
				id,
				text,
				CAST(metadata AS text) as metadata_json,
				CAST(embedding AS text) as embedding_str,
				(embedding #distanceOp# CAST(:embedding AS vector)) as distance
			FROM #variables.table#
			WHERE #whereClause#
			ORDER BY embedding #distanceOp# CAST(:embedding AS vector)
			LIMIT :limit",
			params,
			{ datasource: variables.datasource, returntype: "array" }
		)

		// Transform to standard format with scores (convert distance to similarity)
		return result.map( ( row ) => {
			return {
				id: row.id,
				text: row.text,
				score: convertDistanceToScore( row.distance ),
				metadata: jsonDeserialize( row.metadata_json ),
				embedding: parseVectorString( row.embedding_str )
			};
		} )
	}

	/**
	 * Get all documents from PostgreSQL collection
	 *
	 * @return Array of documents
	 */
	array function getAllDocuments() {
		// Build WHERE clause with userId/conversationId filtering
		var whereClause = "collection = :collection";
		var params = { collection: variables.collection };

		// Only filter by userId if it's set (non-empty)
		if ( len( variables.userId ) ) {
			whereClause &= " AND userId = :userId";
			params.userId = variables.userId;
		}

		// Only filter by conversationId if it's set (non-empty)
		if ( len( variables.conversationId ) ) {
			whereClause &= " AND conversationId = :conversationId";
			params.conversationId = variables.conversationId;
		}

		var result = queryExecute(
			"SELECT
				id,
				text,
				CAST(metadata AS text) AS metadata_json,
				CAST(embedding AS text) AS embedding_str
			FROM #variables.table#
			WHERE #whereClause#
			ORDER BY created_at DESC",
			params,
			{ datasource: variables.datasource, returntype: "array" }
		)

		return result.map( ( row ) => {
			return {
				id: row.id,
				text: row.text,
				metadata: jsonDeserialize( row.metadata_json ),
				embedding: parseVectorString( row.embedding_str )
			}
		} )
	}

	/**
	 * Get document by ID from PostgreSQL
	 *
	 * @id Document ID
	 *
	 * @return Struct document or empty struct
	 */
	struct function getDocumentById( required string id ) {
		var result = queryExecute(
			"SELECT
				id,
				text,
				CAST(metadata AS text) as metadata_json,
				CAST(embedding AS text) as embedding_str
			FROM #variables.table#
			WHERE id = :id AND collection = :collection",
			{
				id: arguments.id,
				collection: variables.collection
			},
			{ datasource: variables.datasource, returntype: "array" }
		)

		if ( result.isEmpty() ) {
			return {}
		}

		var row = result.first()
		return {
			id: row.id,
			text: row.text,
			metadata: jsonDeserialize( row.metadata_json ),
			embedding: parseVectorString( row.embedding_str )
		}
	}

	/**
	 * Delete document by ID from PostgreSQL
	 *
	 * @id Document ID
	 *
	 * @return Boolean success
	 */
	boolean function deleteDocument( required string id ) {
		var result = queryExecute(
			"DELETE FROM #variables.table#
			 WHERE id = :id AND collection = :collection",
			{
				id: arguments.id,
				collection: variables.collection
			},
			{ datasource: variables.datasource, result: "deleteResult" }
		)

		return deleteResult.recordCount > 0
	}

	/**
	 * Delete documents by filter from PostgreSQL
	 *
	 * @filter Metadata filter (JSONB query)
	 *
	 * @return Numeric count deleted
	 */
	numeric function deleteDocumentsByFilter( required struct filter ) {
		var whereClause = "collection = :collection"
		var params = { collection: variables.collection }

		// Add JSONB metadata filters
		if ( !arguments.filter.isEmpty() ) {
			arguments.filter.each( ( key, value ) => {
				whereClause &= " AND metadata->>'#key#' = :#key#"
				params[ key ] = value
			} )
		}

		var result = queryExecute(
			"DELETE FROM #variables.table#
			 WHERE #whereClause#",
			params,
			{ datasource: variables.datasource, result: "deleteResult" }
		)

		return deleteResult.recordCount
	}

	/**
	 * Clear entire collection (delete all documents in this collection)
	 */
	IVectorMemory function clearCollection() {
		queryExecute(
			"DELETE FROM #variables.table# WHERE collection = :collection",
			{ collection: variables.collection },
			{ datasource: variables.datasource }
		)

		return this
	}

	/**
	 * ------------------------------------------------------------------------------
	 * COLLECTION MANAGEMENT
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Create a new collection (table doesn't need per-collection creation, uses collection column)
	 *
	 * @name The collection name
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function createCollection( required string name ) {
		// In PostgreSQL, we use a single table with a collection column
		// So we just need to ensure the table exists
		ensureTable()

		return this
	}

	/**
	 * Check if a collection exists (always true if table exists, as we use collection column)
	 *
	 * @name The collection name
	 *
	 * @return Boolean
	 */
	boolean function collectionExists( required string name ) {
		return tableExists()
	}

	/**
	 * Delete a collection and all its documents
	 *
	 * @name The collection name
	 *
	 * @return IVectorMemory for chaining
	 */
	IVectorMemory function deleteCollection( required string name ) {
		queryExecute(
			"DELETE FROM #variables.table# WHERE collection = :collection",
			{ collection: arguments.name },
			{ datasource: variables.datasource }
		)

		return this
	}

	/**
	 * ------------------------------------------------------------------------------
	 * PRIVATE HELPER METHODS
	 * ------------------------------------------------------------------------------
	 */

	/**
	 * Ensure pgvector extension is enabled
	 */
	private void function ensurePgvectorExtension() {
		try {
			queryExecute(
				"CREATE EXTENSION IF NOT EXISTS vector",
				{},
				{ datasource: variables.datasource }
			)
		} catch ( any e ) {
			throw(
				type = "PostgresVectorMemory.PgvectorError",
				message = "Failed to enable pgvector extension. Ensure PostgreSQL has pgvector installed.",
				detail = e.message
			)
		}
	}

	/**
	 * Ensure the vector table exists
	 */
	private void function ensureTable() {
		// If table exists, nothing to do
		if ( tableExists() ) {
			return
		}

		// Determine dimensions (must be set or detected)
		var dims = variables.dimensions > 0 ? variables.dimensions : 1536; // Default to OpenAI dimensions

		// Create table with vector column
		queryExecute(
			"CREATE TABLE IF NOT EXISTS #variables.table# (
				id VARCHAR(255) NOT NULL,
				collection VARCHAR(255) NOT NULL DEFAULT 'default',
				userId VARCHAR(255) DEFAULT '',
				conversationId VARCHAR(255) DEFAULT '',
				text TEXT NOT NULL,
				embedding vector(#dims#) NOT NULL,
				metadata JSONB DEFAULT '{}'::jsonb,
				created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				PRIMARY KEY (id, collection)
			)",
			{},
			{ datasource: variables.datasource }
		)

		// Create index for collection lookups
		queryExecute(
			"CREATE INDEX IF NOT EXISTS idx_#variables.table#_collection
			 ON #variables.table# (collection)",
			{},
			{ datasource: variables.datasource }
		)

		// Create index for userId lookups
		queryExecute(
			"CREATE INDEX IF NOT EXISTS idx_#variables.table#_userId
			 ON #variables.table# (userId)",
			{},
			{ datasource: variables.datasource }
		)

		// Create index for conversationId lookups
		queryExecute(
			"CREATE INDEX IF NOT EXISTS idx_#variables.table#_conversationId
			 ON #variables.table# (conversationId)",
			{},
			{ datasource: variables.datasource }
		)

		// Create composite index for multi-tenant queries
		queryExecute(
			"CREATE INDEX IF NOT EXISTS idx_#variables.table#_tenant
			 ON #variables.table# (collection, userId, conversationId)",
			{},
			{ datasource: variables.datasource }
		)

		// Create GIN index for metadata JSONB queries
		queryExecute(
			"CREATE INDEX IF NOT EXISTS idx_#variables.table#_metadata
			 ON #variables.table# USING gin (metadata)",
			{},
			{ datasource: variables.datasource }
		)

		// Create vector index based on indexType
		createVectorIndex()
	}

	/**
	 * Create vector similarity index
	 */
	private void function createVectorIndex() {
		var indexOps = static.INDEX_OPS[ variables.distanceFunction ]
		var indexMethod = static.INDEX_TYPES[ variables.indexType ]

		if ( variables.indexType == "HNSW" ) {
			// HNSW index with configurable parameters
			queryExecute(
				"CREATE INDEX IF NOT EXISTS idx_#variables.table#_embedding_hnsw
				 ON #variables.table# USING hnsw (embedding #indexOps#)
				 WITH (m = #variables.hnswM#, ef_construction = #variables.hnswEfConstruction#)",
				{},
				{ datasource: variables.datasource }
			)
		} else {
			// IVFFlat index (faster build, less accurate)
			queryExecute(
				"CREATE INDEX IF NOT EXISTS idx_#variables.table#_embedding_ivfflat
				 ON #variables.table# USING ivfflat (embedding #indexOps#)
				 WITH (lists = 100)",
				{},
				{ datasource: variables.datasource }
			)
		}
	}

	/**
	 * Check if table exists
	 *
	 * @return Boolean
	 */
	private boolean function tableExists() {
		// Check if table exists using DBInfo
		bx:dbinfo
			name="tables"
			type="tables"
			datasource="#variables.datasource#" {}

		var tableExists = false;
		for ( var tableInfo in tables ) {
			if ( tableInfo.table_name.toLowerCase() == variables.table.toLowerCase() ) {
				tableExists = true
				break
			}
		}

		return tableExists
	}

	/**
	 * Convert distance to similarity score (0-1, higher is better)
	 *
	 * @distance The distance from pgvector
	 *
	 * @return Numeric score between 0 and 1
	 */
	private numeric function convertDistanceToScore( required numeric distance ) {
		// For cosine distance: score = 1 - distance (distance is 0-2, we want 0-1)
		// For L2 distance: score = 1 / (1 + distance)
		// For inner product: score = -distance (or normalize based on your needs)

		switch ( variables.distanceFunction ) {
			case "COSINE":
				return max( 0, 1 - arguments.distance )
			case "L2":
				return 1 / ( 1 + arguments.distance )
			case "INNER_PRODUCT":
				// Inner product is negative distance, higher is better
				return -arguments.distance
			default:
				return 1 - arguments.distance
		}
	}

	/**
	 * Parse pgvector string format back to array
	 *
	 * @vectorStr Vector string like "[0.1,0.2,0.3]"
	 *
	 * @return Array of numbers
	 */
	private array function parseVectorString( required string vectorStr ) {
		// Remove brackets and split by comma
		var cleaned = arguments.vectorStr.replace( "[", "" ).replace( "]", "" )
		return cleaned
			.listToArray( "," )
			.map( target => val( target ) )
	}

}
