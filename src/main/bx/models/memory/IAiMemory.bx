/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * Interface for AI Agent Memory implementations
 * Defines the contract for storing and retrieving conversation history
 */
interface {

	/**
	 * ------------------------------------------------------------------------------
	 * CORE IDENTITY METHODS
	 * ------------------------------------------------------------------------------
	 */

	/**
     * Get or set the name of this memory instance
     *
     * @name Optional name to set
     *
     * @return String (getter) or IAiMemory (setter)
     */
    any function name( string name );

    /**
     * Get or set the unique key for this memory instance
	 *
     * @key The unique key string to set, or none to get the current key
	 *
     * @return Struct (getter) or IAiMemory (setter)
     */
    any function key( string key );

    /**
     * Get or set metadata for this memory
	 *
     * @metadata Optional struct to merge with existing metadata
	 *
     * @return Struct (getter) or IAiMemory (setter)
     */
    any function metadata( struct metadata );

	/**
	 * ------------------------------------------------------------------------------
	 * MESSAGE MANAGEMENT METHODS
	 * ------------------------------------------------------------------------------
	 */

    /**
     * Add a message to memory. The message can be:
	 * - A string: The message will be added with the default role (user)
	 * - A struct: The struct must contain at least 'role' and 'content' keys
	 * - An array: Each element will be processed as above
	 * - An AiMessage instance: Its messages will be added
	 * - A Document instance: Its content will be added as a user message
	 *
     * @message
	 *
     * @return IAiMemory for chaining
     */
    IAiMemory function add( required any message );

	/**
	 * Seed memory with multiple messages/documents
	 * Optimized for batch insertion
	 *
	 * @documents Array of messages/documents to add
	 *
	 * @return Struct with results (added, failed, errors)
	 */
	struct function seed( required array documents );

	/**
	 * Seed memory with multiple documents at once asynchronously
	 * This returns a BoxFuture for non-blocking operation
	 *
	 * @documents Array of documents to add. Each document can be:
	 *   - String: Simple text (auto-generates ID)
	 *   - Struct: { text, metadata, id? } (id is optional)
	 *
	 * @return BoxFuture with results: { added: numeric, failed: numeric, errors: array }
	 */
	default BoxFuture function seedAsync( required array documents ){
		// Async in the virtual threads pool
		return asyncRun( () => this.seed( documents ), "io-tasks" );
	}

    /**
     * Get all messages from memory
	 *
     * @return Array of message structs
     */
    array function getAll();

    /**
     * Get recent messages from memory
	 *
     * @limit Number of recent messages to retrieve
	 *
     * @return Array of message structs
     */
    array function getRecent( numeric limit = 10 );

    /**
     * Get messages by role (user, assistant, system, tool)
	 *
     * @role The role to filter by
	 *
     * @return Array of message structs
     */
    array function getByRole( required string role );

    /**
     * Clear all messages from memory
	 *
     * @return IAiMemory for chaining
     */
    IAiMemory function clear();

    /**
     * Get the maximum number of messages this memory can store
     * 0 means unlimited
     *
     * @return Numeric max messages
     */
    numeric function getMaxMessages();

    /**
     * Set the maximum number of messages this memory can store
     * 0 means unlimited
     *
     * @maxMessages Maximum number of messages (0 = unlimited)
     *
     * @return IAiMemory for chaining
     */
    IAiMemory function setMaxMessages( required numeric maxMessages );

	/**
	 * ------------------------------------------------------------------------------
	 *  QUANTITY MANAGEMENT METHODS
	 * ------------------------------------------------------------------------------
	 */

    /**
     * Get the count of messages in memory
	 *
     * @return Numeric count
     */
    numeric function count();

    /**
     * Check if memory is empty
	 *
     * @return True if empty, false otherwise
     */
    boolean function isEmpty();

	/**
	 * ------------------------------------------------------------------------------
	 * SYSTEM MESSAGE METHODS
	 * ------------------------------------------------------------------------------
	 */

    /**
     * Get the system message if one exists
	 *
     * @return The system message or an empty string
     */
    string function getSystemMessage();

    /**
     * Set or replace the system message
	 *
     * @message The system message content (string)
	 *
     * @return IAiMemory for chaining
     */
    IAiMemory function setSystemMessage( required string  message );

    /**
     * Remove the system message
     * @return IAiMemory for chaining
     */
    IAiMemory function removeSystemMessage();

    /**
     * Get messages excluding system message
	 *
     * @return Array of message structs
     */
    array function getNonSystemMessages();

	/**
	 * ------------------------------------------------------------------------------
	 * CONFIGURATION METHODS
	 * ------------------------------------------------------------------------------
	 */

    /**
     * Get configuration struct
	 *
     * @return Struct of configuration
     */
    struct function getConfig();

    /**
     * Configure the memory instance for operation
	 *
     * @config Configuration struct to merge
	 *
     * @return IAiMemory for chaining
     */
    IAiMemory function configure( required struct config );

    /**
     * Get summary of memory instance
     *
     * @return Struct with memory information
     */
    struct function getSummary();

	/**
	 * ------------------------------------------------------------------------------
	 * IMPORT/EXPORT METHODS
	 * ------------------------------------------------------------------------------
	 */



	/**
     * Export memory to a serializable format
     *
     * @return Struct containing all memory data
     */
    struct function export();

	/**
     * Import memory from exported format
     *
     * @data The exported memory data
     *
     * @return IAiMemory for chaining
     */
    IAiMemory function import( required struct data );

	/**
	 * Create a deep copy of this memory instance
	 *
	 * @return A new IAiMemory instance with the same data
	 */
	IAiMemory function clone();

	/**
	 * Merge messages from another memory instance into this one
	 *
	 * @otherMemory The memory instance to merge from
	 * @skipDuplicates Whether to skip duplicate messages (default: false)
	 *
	 * @return IAiMemory for chaining
	 */
	IAiMemory function merge( required IAiMemory otherMemory, boolean skipDuplicates = false );

	/**
	 * ------------------------------------------------------------------------------
	 * SEARCH METHODS (Optional - implement as needed)
	 * ------------------------------------------------------------------------------
	 */	/**
	 * Search messages by content
	 *
	 * @searchTerm Text to search for
	 * @caseSensitive Whether search is case-sensitive
	 *
	 * @return Array of matching message structs
	 */
	array function search( required string searchTerm, boolean caseSensitive = false );

	/**
	 * Get messages in a specific range
	 *
	 * @startIndex Starting index (1-based)
	 * @endIndex Ending index (1-based), Optional, defaults to last message
	 *
	 * @return Array of message structs
	 */
	array function getRange( required numeric startIndex, numeric endIndex );

}