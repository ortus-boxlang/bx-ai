/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * Windowed AI conversation storage leveraging the BoxLang session scope
 * Automatically keeps only the last N messages (sliding window buffer)
 * Perfect for managing conversation context window limits with session persistence
 */
class extends="WindowMemory" {

	/**
	 * Constructor
	 * Initializes the session storage structure
	 *
	 * @key The unique key for this memory instance, defaults to the current session ID
	 * @maxMessages Maximum number of messages to keep (default: 20)
	 */
	function init( string key = "bxai", numeric maxMessages ) {
		super.init( argumentCollection: arguments );

		// Initialize session memory storage if not exists
		ensureSessionStorage();

		return this;
	}

	/**
	 * Override getAll to read from session storage
	 *
	 * @return Array of message structs
	 */
	public array function getAll() {
		ensureSessionStorage();
		return session[ variables.key ].messages;
	}

	/**
	 * Override clear to clear session storage
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function clear() {
		ensureSessionStorage( true );
		return this;
	}

	/**
	 * Override add to store in session
	 * Uses parent's logic but stores in session instead of variables
	 *
	 * @message The message to add
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function add( required any message ) {
		ensureSessionStorage();

		// Temporarily sync messages to variables for parent logic
		variables.messages = session[ variables.key ].messages;

		// Use parent's add logic (handles string, struct, array, AiMessage)
		super.add( arguments.message );

		// Sync back to session
		session[ variables.key ].messages = variables.messages;

		return this;
	}

	/**
	 * Override metadata getter/setter to use session storage
	 *
	 * @metadata Optional struct to merge with existing metadata
	 *
	 * @return Struct (getter) or IAiMemory (setter)
	 */
	public any function metadata( struct metadata ) {
		ensureSessionStorage();

		if ( !isNull( arguments.metadata ) ) {
			session[ variables.key ].metadata.append( arguments.metadata, true );
			return this;
		}

		return session[ variables.key ].metadata;
	}

	/**
	 * Override export to read from session
	 *
	 * @return Struct containing all memory data
	 */
	public struct function export() {
		ensureSessionStorage();

		return {
			key: variables.key,
			name: variables.name,
			maxMessages: variables.maxMessages,
			messages: session[ variables.key ].messages,
			metadata: session[ variables.key ].metadata,
			config: session[ variables.key ].config
		};
	}

	/**
	 * Override import to write to session
	 *
	 * @data The exported memory data
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function import( required struct data ) {
		ensureSessionStorage();

		// Import key and maxMessages
		if ( arguments.data.keyExists( "key" ) ) {
			variables.key = arguments.data.key;
		}
		if ( arguments.data.keyExists( "maxMessages" ) ) {
			variables.maxMessages = arguments.data.maxMessages;
		}

		// Import into session storage
		if ( arguments.data.keyExists( "messages" ) ) {
			session[ variables.key ].messages = arguments.data.messages;
		}
		if ( arguments.data.keyExists( "metadata" ) ) {
			session[ variables.key ].metadata = arguments.data.metadata;
		}
		if ( arguments.data.keyExists( "config" ) ) {
			session[ variables.key ].config = arguments.data.config;
		}

		// Sync to variables for parent trim logic
		variables.messages = session[ variables.key ].messages;
		this.trim();
		session[ variables.key ].messages = variables.messages;

		return this;
	}

	/**
	 * Override count to read from session
	 *
	 * @return Numeric count
	 */
	public numeric function count() {
		ensureSessionStorage();
		return session[ variables.key ].messages.len();
	}

	/**
	 * Override isEmpty to check session storage
	 *
	 * @return True if empty, false otherwise
	 */
	public boolean function isEmpty() {
		ensureSessionStorage();
		return session[ variables.key ].messages.isEmpty();
	}

	/**
	 * Ensure session storage exists for this memory instance
	 * Creates the memory key storage if needed
	 *
	 * @return void
	 */
	private void function ensureSessionStorage( boolean force = false ) {
		if ( !structKeyExists( session, variables.key ) || arguments.force ) {
			session[ variables.key ] = {
				messages: [],
				metadata: {},
				config: {}
			};
		}
	}

}
