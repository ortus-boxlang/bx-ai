/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * JDBC-based AI conversation storage
 * Stores conversation history in a database table for persistence and scalability
 * Works with any JDBC-compatible database
 */
class extends="BaseMemory" {

	/**
	 * The datasource name to use for database operations
	 */
	property name="datasource" type="string";

	/**
	 * The table name to use for storing memory data
	 */
	property name="table" type="string";

	static{
		final DEFAULT_TABLE = "bx_ai_memories"
	}

	/**
	 * Constructor
	 *
	 * @key The unique key for this memory instance
	 * @datasource The datasource name (optional, can be set via configure)
	 * @table The table name (optional, defaults to bx_ai_memories)
	 */
	function init(
		required string key,
		string datasource = "",
		string table = static.DEFAULT_TABLE
	) {
		super.init( arguments.key );
		variables.datasource = arguments.datasource;
		variables.table = arguments.table;
		return this;
	}

	/**
	 * Configure the memory instance
	 * Supports datasource and table in config, ensures table exists
	 */
	public IAiMemory function configure( required struct config ) {
		super.configure( arguments.config );

		if ( arguments.config.keyExists( "datasource" ) ) {
			variables.datasource = arguments.config.datasource;
		}

		if ( arguments.config.keyExists( "table" ) ) {
			variables.table = arguments.config.table;
		}

		// Ensure we have a datasource
		if ( !len( variables.datasource ) ) {
			throw(
				type = "JdbcMemory.MissingDatasource",
				message = "Datasource is required for JdbcMemory. Provide it via constructor or configure()."
			);
		}

		// Ensure table exists
		ensureTable();

		// Load existing data from database if it exists
		loadFromDatabase();

		return this;
	}

	/**
	 * Get or set the datasource name
	 *
	 * @datasource Optional datasource name to set
	 *
	 * @return String (getter) or IAiMemory (setter)
	 */
	public any function datasource( string datasource ) {
		if ( !isNull( arguments.datasource ) ) {
			variables.datasource = arguments.datasource;
			// Ensure table and reload data
			ensureTable();
			loadFromDatabase();
			return this;
		}
		return variables.datasource;
	}

	/**
	 * Get or set the table name
	 *
	 * @table Optional table name to set
	 *
	 * @return String (getter) or IAiMemory (setter)
	 */
	public any function table( string table ) {
		if ( !isNull( arguments.table ) ) {
			variables.table = arguments.table;
			// Ensure table and reload data
			ensureTable();
			loadFromDatabase();
			return this;
		}
		return variables.table;
	}

	/**
	 * Add a message or messages to memory and persist to database
	 */
	public IAiMemory function add( required any message ) {
		super.add( arguments.message );
		saveToDatabase();
		return this;
	}

	/**
	 * Set the system message and persist to database
	 */
	public IAiMemory function setSystemMessage( required string message ) {
		super.setSystemMessage( arguments.message );
		saveToDatabase();
		return this;
	}

	/**
	 * Clear all messages and remove from database
	 */
	public IAiMemory function clear() {
		super.clear();
		deleteFromDatabase();
		return this;
	}

	/**
	 * Export memory state including database-specific fields
	 */
	public struct function export() {
		var exported = super.export();
		exported.datasource = variables.datasource;
		exported.table = variables.table;
		return exported;
	}

	/**
	 * Import memory state and persist to database
	 */
	public IAiMemory function import( required struct data ) {
		super.import( arguments.data );

		// Import database-specific fields
		if ( arguments.data.keyExists( "datasource" ) ) {
			variables.datasource = arguments.data.datasource;
		}
		if ( arguments.data.keyExists( "table" ) ) {
			variables.table = arguments.data.table;
		}

		saveToDatabase();
		return this;
	}

	/**
	 * Get summary including database connection info
	 */
	public struct function getSummary() {
		var summary = super.getSummary();
		summary.datasource = variables.datasource;
		summary.table = variables.table;
		summary.persisted = recordExists();
		return summary;
	}

	// ========================================
	// Private Helper Methods
	// ========================================

	/**
	 * Ensure the database table exists, create if necessary
	 */
	private void function ensureTable() {
		// Check if table exists using DBInfo
		bx:dbinfo
			name="tables"
			type="tables"
			datasource="#variables.datasource#" {};

		var tableExists = false;
		for ( var tableInfo in tables ) {
			if ( tableInfo.table_name.toLowerCase() == variables.table.toLowerCase() ) {
				tableExists = true;
				break;
			}
		}

		if ( !tableExists ) {
			createTable();
		}
	}

	/**
	 * Create the memory table with database-agnostic SQL
	 */
	private void function createTable() {
		// Get database type to use appropriate SQL
		bx:dbinfo
			name="dbVersion"
			type="version"
			datasource="#variables.datasource#" {};
		var dbType = dbVersion.database_productname.toLowerCase();

		// Build CREATE TABLE statement
		// Using CLOB/TEXT for large JSON data storage
		var sql = "
			CREATE TABLE #variables.table# (
				memory_key VARCHAR(255) PRIMARY KEY,
				memory_data CLOB,
				metadata_data CLOB,
				config_data CLOB,
				created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				updated_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
			)
		";

		// Adjust for database-specific types
		if ( dbType.contains( "mysql" ) || dbType.contains( "mariadb" ) ) {
			sql = sql.replace( "CLOB", "LONGTEXT" );
		} else if ( dbType.contains( "postgres" ) ) {
			sql = sql.replace( "CLOB", "TEXT" );
		} else if ( dbType.contains( "sqlserver" ) || dbType.contains( "microsoft" ) ) {
			sql = sql.replace( "CLOB", "NVARCHAR(MAX)" );
		} else if ( dbType.contains( "oracle" ) ) {
			// Oracle uses CLOB
		}

		queryExecute(
			sql,
			{},
			{ datasource: variables.datasource }
		);
	}

	/**
	 * Load data from database if record exists
	 */
	private void function loadFromDatabase() {
		if ( !recordExists() ) {
			return;
		}

		var result = queryExecute(
			"SELECT memory_data, metadata_data, config_data FROM #variables.table# WHERE memory_key = :key",
			{ key: variables.key },
			{ datasource: variables.datasource, returntype: "array" }
		);

		if ( result.len() > 0 ) {
			var record = result[1];

			// Deserialize messages
			if ( len( record.memory_data ) ) {
				try {
					variables.messages = deserializeJSON( record.memory_data );
				} catch ( any e ) {
					// If deserialization fails, start with empty array
					variables.messages = [];
				}
			}

			// Deserialize metadata
			if ( len( record.metadata_data ) ) {
				try {
					variables.metadata = deserializeJSON( record.metadata_data );
				} catch ( any e ) {
					variables.metadata = {};
				}
			}

			// Deserialize config
			if ( len( record.config_data ) ) {
				try {
					variables.config = deserializeJSON( record.config_data );
				} catch ( any e ) {
					variables.config = {};
				}
			}
		}
	}

	/**
	 * Save current state to database (INSERT or UPDATE)
	 */
	private void function saveToDatabase() {
		if ( !len( variables.datasource ) ) {
			return;
		}

		var messagesJson = serializeJSON( variables.messages );
		var metadataJson = serializeJSON( variables.metadata );
		var configJson = serializeJSON( variables.config );

		if ( recordExists() ) {
			// Update existing record
			queryExecute(
				"UPDATE #variables.table#
				 SET memory_data = :messages,
				     metadata_data = :metadata,
				     config_data = :config,
				     updated_date = CURRENT_TIMESTAMP
				 WHERE memory_key = :key",
				{
					key: variables.key,
					messages: messagesJson,
					metadata: metadataJson,
					config: configJson
				},
				{ datasource: variables.datasource }
			);
		} else {
			// Insert new record
			queryExecute(
				"INSERT INTO #variables.table# (memory_key, memory_data, metadata_data, config_data)
				 VALUES (:key, :messages, :metadata, :config)",
				{
					key: variables.key,
					messages: messagesJson,
					metadata: metadataJson,
					config: configJson
				},
				{ datasource: variables.datasource }
			);
		}
	}

	/**
	 * Delete record from database
	 */
	private void function deleteFromDatabase() {
		if ( !len( variables.datasource ) ) {
			return;
		}

		queryExecute(
			"DELETE FROM #variables.table# WHERE memory_key = :key",
			{ key: variables.key },
			{ datasource: variables.datasource }
		);
	}

	/**
	 * Check if a record exists in the database
	 *
	 * @return Boolean
	 */
	private boolean function recordExists() {
		if ( !len( variables.datasource ) ) {
			return false;
		}

		var result = queryExecute(
			"SELECT COUNT(*) as record_count FROM #variables.table# WHERE memory_key = :key",
			{ key: variables.key },
			{ datasource: variables.datasource, returntype: "array" }
		);

		return result.len() > 0 && result[1].record_count > 0;
	}

}
