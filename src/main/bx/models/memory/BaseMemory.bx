/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * Base abstract class for AI Memory implementations
 * Provides common functionality for conversation history storage
 */
abstract class implements="IAiMemory" {

	/**
	 * Unique key for this memory instance
	 */
	property name="key" type="string" default="";

	/**
	 * Metadata for this memory instance
	 */
	property name="metadata" type="struct" default={};

	/**
	 * Memory instance name (defaults to class name via getMetadata)
	 */
	property name="name" type="string" default="";

	/**
	 * Configuration for this memory instance
	 */
	property name="config" type="struct" default={};

	/**
	 * Messages stored in memory
	 */
	property name="messages" type="array" default=[];

	/**
	 * Maximum number of messages to store (0 = unlimited)
	 */
	property name="maxMessages" type="numeric";

	/**
	 * Constants
	 */
	static {
		final settings = getModuleInfo( "bxai" ).settings
		final DEFAULT_MAX_MESSAGES = 100
	}

	/**
	 * Constructor - sets default name from class metadata
	 *
	 * @key The unique key for this memory instance
	 */
	function init( string key = createUUID(), numeric maxMessages = static.DEFAULT_MAX_MESSAGES  ) {
		variables.key = arguments.key
		var fullName = getMetadata( this ).name ?: "BaseMemory"
		variables.name = fullName.listLast( "." )
		variables.maxMessages = arguments.maxMessages
		return this
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * Interface Methods
	 * ---------------------------------------------------------------------------------------------------------
	 */

	/**
	 * Get or set the unique key for this memory instance
	 *
	 * @key The unique key string to set, or none to get the current key
	 *
	 * @return Struct (getter) or IAiMemory (setter)
	 */
	public any function key( string key ) {
		if ( !isNull( arguments.key ) ) {
			variables.key = arguments.key
			return this
		}
		return variables.key
	}

	/**
	 * Get or set metadata for this memory
	 *
	 * @metadata Optional struct to merge with existing metadata
	 *
	 * @return Struct (getter) or IAiMemory (setter)
	 */
	public any function metadata( struct metadata ) {
		if ( !isNull( arguments.metadata ) ) {
			variables.metadata = arguments.metadata
			return this
		}
		return variables.metadata
	}

	/**
	 * Add a message to memory. The message can be:
	 * - A string: The message will be added with the default role (user)
	 * - A struct: The struct must contain at least 'role' and 'content' keys
	 * - An array: Each element will be processed as above
	 * - An AiMessage instance: Its messages will be added
	 *
	 * @message The message to add
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function add( required any message ) {
		processMessage( arguments.message )
			.each( msg => {
				variables.messages.append( msg )
			} )

		// Trim to max size (excluding system message)
		this.trim()

		return this
	}

	/**
	 * Get all messages from memory
	 *
	 * @return Array of message structs
	 */
	public array function getAll() {
		return variables.messages
	}

	/**
	 * Get recent messages from memory
	 *
	 * @limit Number of recent messages to retrieve
	 *
	 * @return Array of message structs
	 */
	public array function getRecent( numeric limit = 10 ) {
		var allMessages = getAll()
		var total = allMessages.len()

		// If total messages less than or equal to limit, return all
		if ( total <= arguments.limit ) {
			return allMessages
		}

		var start = total - arguments.limit + 1
		return allMessages.slice( start, total )
	}

	/**
	 * Get messages by role (user, assistant, system, tool)
	 *
	 * @role The role to filter by
	 *
	 * @return Array of message structs
	 */
	public array function getByRole( required string role ) {
		return this.getAll().filter( ( m ) => m.role == role )
	}

	/**
	 * Clear all messages from memory
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function clear() {
		variables.messages = []
		return this
	}

	/**
	 * Get the count of messages in memory
	 *
	 * @return Numeric count
	 */
	public numeric function count() {
		return getAll().len()
	}

	/**
	 * Check if memory is empty
	 *
	 * @return True if empty, false otherwise
	 */
	public boolean function isEmpty() {
		return getAll().isEmpty()
	}

	/**
	 * Get the system message if one exists
	 *
	 * @return The system message content or an empty string
	 */
	public string function getSystemMessage() {
		var systemMessages = getByRole( "system" )
		if ( systemMessages.isEmpty() ) {
			return ""
		}
		return systemMessages.first().content
	}

	/**
	 * Do you have a system message?
	 *
	 * @return True if a system message exists, false otherwise
	 */
	public boolean function hasSystemMessage() {
		return !getByRole( "system" ).isEmpty()
	}

	/**
	 * Set or replace the system message
	 *
	 * @message The system message content (string)
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function setSystemMessage( required string message ) {
		// Remove existing system message if any
		removeSystemMessage()

		// Add new system message at the beginning
		getAll().prepend( {
			role: "system",
			content: arguments.message,
			timestamp: now()
		} )

		// Trim to max size, just in case
		this.trim()

		return this
	}

	/**
	 * Remove the system message
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function removeSystemMessage() {
		variables.messages = getAll().filter( ( m ) => m.role != "system" )
		return this
	}

	/**
	 * Get messages excluding system message
	 *
	 * @return Array of message structs
	 */
	public array function getNonSystemMessages() {
		return getAll().filter( ( m ) => m.role != "system" )
	}

	/**
	 * Search messages by content
	 *
	 * @searchTerm Text to search for
	 * @caseSensitive Whether search is case-sensitive (default: false)
	 *
	 * @return Array of matching message structs
	 */
	public array function search( required string searchTerm, boolean caseSensitive = false ) {
		var term = arguments.searchTerm
		var isCaseSensitive = arguments.caseSensitive

		return getAll().filter( ( message ) => {
			return isCaseSensitive
				? message.content.find( term ) > 0
				: message.content.findNoCase( term ) > 0
		} )
	}

	/**
	 * Get messages in a specific range
	 *
	 * @startIndex Starting index (1-based)
	 * @endIndex Ending index (1-based), optional - defaults to last message
	 *
	 * @return Array of message structs
	 */
	public array function getRange( required numeric startIndex, numeric endIndex ) {
		var messages = getAll()
		var total = messages.len()

		// Validate startIndex - must be within bounds
		if ( arguments.startIndex < 1 || arguments.startIndex > total ) {
			return []
		}

		// Default endIndex to last message if not provided
		var finalEndIndex = isNull( arguments.endIndex ) ? total : arguments.endIndex

		// Clamp endIndex to valid range
		if ( finalEndIndex > total ) {
			finalEndIndex = total
		}

		// If endIndex is before startIndex, return empty
		if ( finalEndIndex < arguments.startIndex ) {
			return []
		}

		// Calculate length for slice (slice takes start and length, not start and end)
		var length = finalEndIndex - arguments.startIndex + 1
		return messages.slice( arguments.startIndex, length )
	}

	/**
	 * Get or set the name of this memory instance
	 *
	 * @name Optional name to set
	 *
	 * @return String (getter) or IAiMemory (setter)
	 */
	public any function name( string name ) {
		if ( !isNull( arguments.name ) ) {
			variables.name = arguments.name
			return this
		}
		return variables.name
	}

	/**
	 * Configure the memory instance for operation
	 *
	 * @config Configuration struct to merge
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function configure( required struct config ) {
		variables.config.append( arguments.config, true )

		if ( arguments.config.keyExists( "maxMessages" ) ) {
			variables.maxMessages = arguments.config.maxMessages
		}

		return this
	}

	/**
	 * Get a summary of this memory instance
	 * Subclasses can override to add specific fields
	 *
	 * @return Struct with memory information
	 */
	public struct function getSummary() {
		var allMessages = getAll()
		return {
			"type": this.name(),
			"key": this.key(),
			"messageCount": count(),
			"maxMessages": variables.maxMessages,
			"nonSystemCount": getNonSystemMessages().len(),
			"hasSystemMessage": hasSystemMessage(),
			"metadata": this.metadata(),
			"config": getConfig(),
			"firstMessageAt": allMessages.isEmpty() ? "" : allMessages.first().timestamp,
        	"lastMessageAt": allMessages.isEmpty() ? "" : allMessages.last().timestamp
		}
	}

	/**
	 * Export messages to a serializable format
	 * Subclasses can override to add specific fields
	 *
	 * @return Struct containing all memory data
	 */
	public struct function export() {
		return {
			"type":this. name(),
			"key": this.key(),
			"metadata": this.metadata(),
			"config": getConfig(),
			"messages": getAll(),
			"maxMessages": variables.maxMessages
		}
	}

	/**
	 * Import messages from a previously exported format
	 * Subclasses can override to handle specific fields
	 *
	 * @data The exported memory data
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function import( required struct data ) {
		if ( arguments.data.keyExists( "key" ) ) {
			variables.key = arguments.data.key
		}
		if ( arguments.data.keyExists( "metadata" ) ) {
			variables.metadata = arguments.data.metadata
		}
		if ( arguments.data.keyExists( "config" ) ) {
			variables.config = arguments.data.config
		}
		if ( arguments.data.keyExists( "maxMessages" ) ) {
			variables.maxMessages = arguments.data.maxMessages
		}
		if ( arguments.data.keyExists( "messages" ) && isArray( arguments.data.messages ) ) {
			variables.messages = arguments.data.messages
		}

		// Ensure we respect maxMessages after import
		this.trim()
		return this
	}

	/**
	 * Create a deep copy of this memory instance
	 *
	 * @return A new IAiMemory instance with the same data
	 */
	public IAiMemory function clone() {
		// Export current state and deep copy it
		var exported = duplicate( this.export() )

		// Create new instance of same type with the same key
		var cloned = createObject( "component", getMetadata( this ).name ).init( exported.key )

		// Import data into new instance
		cloned.import( exported )

		return cloned
	}

	/**
	 * Merge messages from another memory instance into this one
	 *
	 * @otherMemory The memory instance to merge from
	 * @skipDuplicates Whether to skip duplicate messages based on content and role (default: false)
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function merge( required IAiMemory otherMemory, boolean skipDuplicates = false ) {
		var otherMessages = arguments.otherMemory.getAll()

		if ( arguments.skipDuplicates ) {
			var existingMessages = this.getAll()

			// Filter out duplicates by comparing role and content
			otherMessages = otherMessages.filter( ( newMsg ) => {
				return !existingMessages.some( ( existingMsg ) =>
					existingMsg.role == newMsg.role && existingMsg.content == newMsg.content
				)
			} )
		}

		// Add all messages (duplicates already filtered if requested)
		otherMessages.each( ( msg ) => this.add( msg ) )

		return this
	}

	/**
	 * Trim messages to keep only the last N (excluding system message)
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function trim() {
		// If maxMessages is 0, do not trim
		if ( variables.maxMessages == 0 ) {
			return this
		}

		var hasSystem = hasSystemMessage()
    	var systemMsg = hasSystem ? getSystemMessage() : ""
		var nonSystemMessages = getNonSystemMessages()

		// If we're over the limit, keep only the last N
		if ( nonSystemMessages.len() > variables.maxMessages ) {
			var start = nonSystemMessages.len() - variables.maxMessages + 1
        	var keep = nonSystemMessages.slice( start, nonSystemMessages.len() )

			// Clear all messages
        	this.clear()

			// Add back system message if it existed
			// Avoid calling add to prevent trimming again
			if ( hasSystem ) {
				keep.prepend( {
					role: "system",
					content: systemMsg,
					timestamp: now()
				} )
			}

			// Add back the kept messages
			variables.messages = keep
		}

		return this
	}

	/**
	 * Set the maximum messages limit
	 * Triggers trim if current count exceeds new limit
	 *
	 * @maxMessages The new maximum
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function setMaxMessages( required numeric maxMessages ) {
		variables.maxMessages = arguments.maxMessages
		this.trim()
		return this
	}

	/**
	 * Take a raw message input and convert it to a standard message struct
	 *
	 * Supports:
	 * - A string: The message will be added with the default role (user)
	 * - A struct: The struct must contain at least 'role' and 'content' keys
	 * - An array: Each element will be processed as above
	 * - An AiMessage instance: Its messages will be added
	 *
	 * @message The message to process
	 *
	 * @return The processed message as an array of message structs
	 */
	private array function processMessage( required any message){
		// AiMessage instance - return it's state, it is supposed to be clean
 		if ( arguments.message instanceof "AiMessage" ) {
			return 	arguments.message.getMessages()
		}

		// Struct - must have role and content
		if ( isStruct( arguments.message ) ) {
			param arguments.message.role = "user"
			param arguments.message.timestamp = now()
			if ( !arguments.message.keyExists( "content" ) ) {
				throw(
					type: "InvalidMessage",
					message: "Message struct must contain a 'content' key"
				)
			}
			return [ arguments.message ]
		}

		// Array - process each element and return the array of processed messages
		 if ( isArray( arguments.message ) ) {
			return arguments.message.map( ( m ) =>processMessage( m ) )
		}

		// String - Create user message struct
		if ( isSimpleValue( arguments.message ) ) {
			return [ {
				role: "user",
				content: arguments.message,
				timestamp: now()
			} ]
		}

		throw(
			type: "InvalidMessage",
			message: "Message must be a string, struct, array, or AiMessage instance"
		)
	}

}
