/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 * ----------------------------------------------------------------------------------
 * Base abstract class for AI Memory implementations
 * Provides common functionality for conversation history storage
 */
abstract class implements="IAiMemory" {

	/**
	 * Unique key for this memory instance
	 */
	property name="key" type="string" default="";

	/**
	 * Metadata for this memory instance
	 */
	property name="metadata" type="struct" default={};

	/**
	 * Memory instance name (defaults to class name via getMetadata)
	 */
	property name="name" type="string" default="";

	/**
	 * Configuration for this memory instance
	 */
	property name="config" type="struct" default={};

	/**
	 * Messages stored in memory
	 */
	property name="messages" type="array" default=[];

	/**
	 * Constants
	 */
	static {
		final settings = getModuleInfo( "bxai" ).settings
	}

	/**
	 * Constructor - sets default name from class metadata
	 *
	 * @key The unique key for this memory instance
	 */
	function init( required string key ) {
		variables.key = arguments.key;
		var fullName = getMetadata( this ).name ?: "BaseMemory";
		variables.name = fullName.listLast( "." );
		return this;
	}

	/**
	 * ---------------------------------------------------------------------------------------------------------
	 * Interface Methods
	 * ---------------------------------------------------------------------------------------------------------
	 */

	/**
	 * Get or set the unique key for this memory instance
	 *
	 * @key The unique key string to set, or none to get the current key
	 *
	 * @return Struct (getter) or IAiMemory (setter)
	 */
	public any function key( string key ) {
		if ( !isNull( arguments.key ) ) {
			variables.key = arguments.key;
			return this;
		}
		return variables.key;
	}

	/**
	 * Get or set metadata for this memory
	 *
	 * @metadata Optional struct to merge with existing metadata
	 *
	 * @return Struct (getter) or IAiMemory (setter)
	 */
	public any function metadata( struct metadata ) {
		if ( !isNull( arguments.metadata ) ) {
			variables.metadata.append( arguments.metadata, true );
			return this;
		}
		return variables.metadata;
	}

	/**
	 * Add a message to memory. The message can be:
	 * - A string: The message will be added with the default role (user)
	 * - A struct: The struct must contain at least 'role' and 'content' keys
	 * - An array: Each element will be processed as above
	 * - An AiMessage instance: Its messages will be added
	 *
	 * @message The message to add
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function add( required any message ) {
		// String - add as user message
		if ( isSimpleValue( arguments.message ) ) {
			variables.messages.append( {
				role: "user",
				content: arguments.message,
				timestamp: now()
			} );
		}
		// AiMessage instance - get its messages
		else if ( arguments.message instanceof "AiMessage" ) {
			add( arguments.message.getMessages() );
		}
		// Struct - must have role and content
		else if ( isStruct( arguments.message ) ) {
			if ( !arguments.message.keyExists( "role" ) || !arguments.message.keyExists( "content" ) ) {
				throw(
					type: "InvalidMessage",
					message: "Message struct must contain 'role' and 'content' keys"
				);
			}
			var msg = duplicate( arguments.message );
			// Add timestamp if not present
			if ( !msg.keyExists( "timestamp" ) ) {
				msg.timestamp = now();
			}
			variables.messages.append( msg );
		}
		// Array - process each element
		else if ( isArray( arguments.message ) ) {
			arguments.message.each( ( m ) => add( m ) );
		}
		// Invalid type
		else {
			throw(
				type: "InvalidMessage",
				message: "Message must be a string, struct, array, or AiMessage instance"
			);
		}

		return this;
	}

	/**
	 * Get all messages from memory
	 *
	 * @return Array of message structs
	 */
	public array function getAll() {
		return variables.messages
	}

	/**
	 * Get recent messages from memory
	 *
	 * @limit Number of recent messages to retrieve
	 *
	 * @return Array of message structs
	 */
	public array function getRecent( numeric limit = 10 ) {
		var allMessages = getAll();
		var total = allMessages.len();

		// If total messages less than or equal to limit, return all
		if ( total <= arguments.limit ) {
			return allMessages;
		}

		var start = total - arguments.limit + 1;
		return allMessages.slice( start, total );
	}

	/**
	 * Get messages by role (user, assistant, system, tool)
	 *
	 * @role The role to filter by
	 *
	 * @return Array of message structs
	 */
	public array function getByRole( required string role ) {
		return getAll().filter( ( m ) => m.role == role );
	}

	/**
	 * Clear all messages from memory
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function clear() {
		variables.messages = [];
		return this;
	}

	/**
	 * Get the count of messages in memory
	 *
	 * @return Numeric count
	 */
	public numeric function count() {
		return getAll().len();
	}

	/**
	 * Check if memory is empty
	 *
	 * @return True if empty, false otherwise
	 */
	public boolean function isEmpty() {
		return getAll().isEmpty();
	}

	/**
	 * Get the system message if one exists
	 *
	 * @return The system message content or an empty string
	 */
	public string function getSystemMessage() {
		var systemMessages = getByRole( "system" );
		if ( systemMessages.isEmpty() ) {
			return "";
		}
		return systemMessages.first().content;
	}

	/**
	 * Do you have a system message?
	 *
	 * @return True if a system message exists, false otherwise
	 */
	public boolean function hasSystemMessage() {
		return !getByRole( "system" ).isEmpty();
	}

	/**
	 * Set or replace the system message
	 *
	 * @message The system message content (string)
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function setSystemMessage( required string message ) {
		// Remove existing system message if any
		removeSystemMessage();

		// Add new system message at the beginning
		getAll().prepend( {
			role: "system",
			content: arguments.message,
			timestamp: now()
		} );

		return this;
	}

	/**
	 * Remove the system message
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function removeSystemMessage() {
		variables.messages = getAll().filter( ( m ) => m.role != "system" );
		return this;
	}

	/**
	 * Get messages excluding system message
	 *
	 * @return Array of message structs
	 */
	public array function getNonSystemMessages() {
		return getAll().filter( ( m ) => m.role != "system" );
	}

	/**
	 * Search messages by content
	 *
	 * @searchTerm Text to search for
	 * @caseSensitive Whether search is case-sensitive (default: false)
	 *
	 * @return Array of matching message structs
	 */
	public array function search( required string searchTerm, boolean caseSensitive = false ) {
		var term = arguments.searchTerm;
		var isCaseSensitive = arguments.caseSensitive;

		return getAll().filter( ( message ) => {
			return isCaseSensitive
				? message.content.find( term ) > 0
				: message.content.findNoCase( term ) > 0;
		} );
	}	/**
	 * Get messages in a specific range
	 *
	 * @startIndex Starting index (1-based)
	 * @endIndex Ending index (1-based), optional - defaults to last message
	 *
	 * @return Array of message structs
	 */
	public array function getRange( required numeric startIndex, numeric endIndex ) {
		var messages = getAll();
		var total = messages.len();

		// Validate startIndex - must be within bounds
		if ( arguments.startIndex < 1 || arguments.startIndex > total ) {
			return [];
		}

		// Default endIndex to last message if not provided
		var finalEndIndex = isNull( arguments.endIndex ) ? total : arguments.endIndex;

		// Clamp endIndex to valid range
		if ( finalEndIndex > total ) {
			finalEndIndex = total;
		}

		// If endIndex is before startIndex, return empty
		if ( finalEndIndex < arguments.startIndex ) {
			return [];
		}

		// Calculate length for slice (slice takes start and length, not start and end)
		var length = finalEndIndex - arguments.startIndex + 1;
		return messages.slice( arguments.startIndex, length );
	}

	/**
	 * Get or set the name of this memory instance
	 *
	 * @name Optional name to set
	 *
	 * @return String (getter) or IAiMemory (setter)
	 */
	public any function name( string name ) {
		if ( !isNull( arguments.name ) ) {
			variables.name = arguments.name;
			return this;
		}
		return variables.name;
	}

	/**
	 * Configure the memory instance for operation
	 *
	 * @config Configuration struct to merge
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function configure( required struct config ) {
		variables.config.append( arguments.config, true );
		return this;
	}

	/**
	 * Get a summary of this memory instance
	 * Subclasses can override to add specific fields
	 *
	 * @return Struct with memory information
	 */
	public struct function getSummary() {
		var allMessages = getAll();
		return {
			"type": name(),
			"key": key(),
			"messageCount": count(),
			"nonSystemCount": getNonSystemMessages().len(),
			"hasSystemMessage": hasSystemMessage(),
			"metadata": metadata(),
			"config": getConfig(),
			"firstMessageAt": allMessages.isEmpty() ? "" : allMessages.first().timestamp,
        	"lastMessageAt": allMessages.isEmpty() ? "" : allMessages.last().timestamp
		};
	}

	/**
	 * Export messages to a serializable format
	 * Subclasses can override to add specific fields
	 *
	 * @return Struct containing all memory data
	 */
	public struct function export() {
		return {
			"type": name(),
			"key": key(),
			"metadata": metadata(),
			"config": getConfig(),
			"messages": getAll()
		};
	}

	/**
	 * Import messages from a previously exported format
	 * Subclasses can override to handle specific fields
	 *
	 * @data The exported memory data
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function import( required struct data ) {
		if ( arguments.data.keyExists( "key" ) ) {
			variables.key = arguments.data.key;
		}
		if ( arguments.data.keyExists( "metadata" ) ) {
			variables.metadata = arguments.data.metadata;
		}
		if ( arguments.data.keyExists( "config" ) ) {
			variables.config = arguments.data.config;
		}
		if ( arguments.data.keyExists( "messages" ) && isArray( arguments.data.messages ) ) {
			variables.messages = arguments.data.messages;
		}
		return this;
	}

	/**
	 * Create a deep copy of this memory instance
	 *
	 * @return A new IAiMemory instance with the same data
	 */
	public IAiMemory function clone() {
		// Export current state and deep copy it
		var exported = duplicate( this.export() );

		// Create new instance of same type with the same key
		var cloned = createObject( "component", getMetadata( this ).name ).init( exported.key );

		// Import data into new instance
		cloned.import( exported );

		return cloned;
	}

	/**
	 * Merge messages from another memory instance into this one
	 *
	 * @otherMemory The memory instance to merge from
	 * @skipDuplicates Whether to skip duplicate messages based on content and role (default: false)
	 *
	 * @return IAiMemory for chaining
	 */
	public IAiMemory function merge( required IAiMemory otherMemory, boolean skipDuplicates = false ) {
		var otherMessages = arguments.otherMemory.getAll();

		if ( arguments.skipDuplicates ) {
			var existingMessages = this.getAll();

			// Filter out duplicates by comparing role and content
			otherMessages = otherMessages.filter( ( newMsg ) => {
				return !existingMessages.some( ( existingMsg ) =>
					existingMsg.role == newMsg.role && existingMsg.content == newMsg.content
				);
			} );
		}

		// Add all messages (duplicates already filtered if requested)
		otherMessages.each( ( msg ) => this.add( msg ) );

		return this;
	}

}
