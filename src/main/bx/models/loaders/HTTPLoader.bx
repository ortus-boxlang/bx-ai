/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * HTTP Document Loader
 * Loads content from HTTP/HTTPS URLs with configurable content type handling.
 */
class extends="BaseDocumentLoader" {

	/**
	 * Static loader configuration defaults
	 */
	static {
		DEFAULT_CONFIG = {
			encoding        : "UTF-8",
			includeMetadata : true,
			splitMode       : "none",
			continueOnError : true,
			// HTTP-specific defaults
			contentType     : "auto",       // auto, text, html, json, xml
			method          : "GET",
			headers         : {},
			timeout         : 30,
			followRedirects : true,
			userAgent       : "BoxLang-AI-HTTPLoader/1.0",
			// Processing options
			extractText     : true,         // Extract text from HTML
			removeScripts   : true,         // Remove script tags from HTML
			removeStyles    : true          // Remove style tags from HTML
		};
	}

	/**
	 * Initialize the HTTP loader
	 *
	 * @source The URL to load from
	 * @config Configuration options
	 *
	 * @return HTTPLoader instance
	 */
	function init( string source = "", struct config = {} ) {
		super.init( argumentCollection: arguments );
		variables.config = static.DEFAULT_CONFIG.append( variables.config, true );
		return this;
	}

	/**
	 * Get the loader name
	 */
	string function getName() {
		return "HTTPLoader";
	}

	/**
	 * Set the HTTP method (GET, POST, etc.)
	 *
	 * @method The HTTP method
	 *
	 * @return HTTPLoader for chaining
	 */
	HTTPLoader function method( required string method ) {
		variables.config.method = arguments.method.uCase();
		return this;
	}

	/**
	 * Set request headers
	 *
	 * @headers Struct of headers to add
	 *
	 * @return HTTPLoader for chaining
	 */
	HTTPLoader function headers( required struct headers ) {
		variables.config.headers.append( arguments.headers, true );
		return this;
	}

	/**
	 * Add a single header
	 *
	 * @name Header name
	 * @value Header value
	 *
	 * @return HTTPLoader for chaining
	 */
	HTTPLoader function addHeader( required string name, required string value ) {
		variables.config.headers[ arguments.name ] = arguments.value;
		return this;
	}

	/**
	 * Set the content type for parsing
	 *
	 * @type Content type (auto, text, html, json, xml)
	 *
	 * @return HTTPLoader for chaining
	 */
	HTTPLoader function contentType( required string type ) {
		variables.config.contentType = arguments.type.lCase();
		return this;
	}

	/**
	 * Set request timeout
	 *
	 * @seconds Timeout in seconds
	 *
	 * @return HTTPLoader for chaining
	 */
	HTTPLoader function timeout( required numeric seconds ) {
		variables.config.timeout = arguments.seconds;
		return this;
	}

	/**
	 * Configure whether to extract text from HTML
	 *
	 * @extract Whether to extract text
	 *
	 * @return HTTPLoader for chaining
	 */
	HTTPLoader function extractText( boolean extract = true ) {
		variables.config.extractText = arguments.extract;
		return this;
	}

	/**
	 * Load the document from the URL
	 *
	 * @return Array of Document objects
	 */
	array function load() {
		if ( variables.source.isEmpty() ) {
			throw( type: "HTTPLoader.MissingSource", message: "No URL source specified for HTTPLoader" );
		}

		try {
			// Build and execute HTTP request using the http() BIF
			var httpRequest = http(
				url     : variables.source,
				method  : variables.config.method,
				timeout : variables.config.timeout
			);

			// Add custom headers
			for ( var headerName in variables.config.headers ) {
				httpRequest.addHeader( headerName, variables.config.headers[ headerName ] );
			}

			// Add user agent
			httpRequest.addHeader( "User-Agent", variables.config.userAgent );

			// Execute request
			var response = httpRequest.send().getPrefix();

			// Validate response
			if ( response.statusCode >= 400 ) {
				if ( variables.config.continueOnError ) {
					addError( {
						"message"    : "HTTP request failed with status #response.statusCode#",
						"statusCode" : response.statusCode,
						"url"        : variables.source
					} );
					return [];
				}
				throw(
					type    : "HTTPLoader.RequestFailed",
					message : "HTTP request failed with status #response.statusCode#: #response.statusText#"
				);
			}

			// Get content and process based on type
			var content        = response.fileContent;
			var detectedType   = detectContentType( response );
			var processedContent = processContent( content, detectedType );

			// Build metadata
			var metadata = {
				"url"              : variables.source,
				"statusCode"       : response.statusCode,
				"contentType"      : detectedType,
				"responseHeaders"  : response.responseHeader ?: {},
				"charset"          : response.charset ?: variables.config.encoding,
				"contentLength"    : len( content ),
				"fileType"         : detectedType
			};

			return [ createDocument( content: processedContent, additionalMetadata: metadata ) ];

		} catch ( any e ) {
			if ( variables.config.continueOnError ) {
				addError( {
					"message" : e.message,
					"type"    : e.type,
					"url"     : variables.source
				} );
				return [];
			}
			rethrow;
		}
	}

	/**
	 * Detect content type from response
	 *
	 * @response The HTTP response
	 *
	 * @return String content type
	 */
	private string function detectContentType( required struct response ) {
		// If explicit type configured, use that
		if ( variables.config.contentType != "auto" ) {
			return variables.config.contentType;
		}

		// Try to detect from response headers
		var contentTypeHeader = arguments.response.responseHeader[ "Content-Type" ] ?: "";

		if ( contentTypeHeader.findNoCase( "application/json" ) > 0 ) {
			return "json";
		} else if ( contentTypeHeader.findNoCase( "text/html" ) > 0 || contentTypeHeader.findNoCase( "application/xhtml" ) > 0 ) {
			return "html";
		} else if ( contentTypeHeader.findNoCase( "text/xml" ) > 0 || contentTypeHeader.findNoCase( "application/xml" ) > 0 ) {
			return "xml";
		} else if ( contentTypeHeader.findNoCase( "text/" ) > 0 ) {
			return "text";
		}

		// Try to detect from URL extension
		var url = variables.source.lCase();
		if ( url.endsWith( ".json" ) ) {
			return "json";
		} else if ( url.endsWith( ".html" ) || url.endsWith( ".htm" ) ) {
			return "html";
		} else if ( url.endsWith( ".xml" ) ) {
			return "xml";
		}

		// Default to text
		return "text";
	}

	/**
	 * Process content based on detected type
	 *
	 * @content The raw content
	 * @type The detected content type
	 *
	 * @return Processed content string
	 */
	private string function processContent( required string content, required string type ) {
		switch ( arguments.type ) {
			case "html": {
				if ( variables.config.extractText ) {
					return extractTextFromHTML( arguments.content );
				}
				return arguments.content;
			}
			case "json": {
				// Pretty-format JSON for readability
				try {
					var parsed = jsonDeserialize( arguments.content );
					return jsonSerialize( parsed );
				} catch ( any e ) {
					return arguments.content;
				}
			}
			case "xml": {
				// Return raw XML (could add text extraction later)
				return arguments.content;
			}
			default: {
				return arguments.content;
			}
		}
	}

	/**
	 * Extract text content from HTML
	 *
	 * @html The HTML content
	 *
	 * @return Extracted text
	 */
	private string function extractTextFromHTML( required string html ) {
		var text = arguments.html;

		// Remove script tags
		if ( variables.config.removeScripts ) {
			text = reReplace( text, "<script[^>]*>[\s\S]*?</script>", "", "all" );
		}

		// Remove style tags
		if ( variables.config.removeStyles ) {
			text = reReplace( text, "<style[^>]*>[\s\S]*?</style>", "", "all" );
		}

		// Remove HTML comments
		text = reReplace( text, "<!--[\s\S]*?-->", "", "all" );

		// Remove all HTML tags
		text = reReplace( text, "<[^>]+>", " ", "all" );

		// Decode HTML entities
		text = htmlDecode( text );

		// Normalize whitespace
		text = reReplace( text, "\s+", " ", "all" );

		return trim( text );
	}

	/**
	 * Get source metadata for HTTP
	 *
	 * @return Struct with metadata
	 */
	struct function getSourceMetadata() {
		return {
			"source"      : variables.source,
			"loader"      : getName(),
			"isURL"       : true,
			"method"      : variables.config.method,
			"contentType" : variables.config.contentType,
			"timeout"     : variables.config.timeout
		};
	}

	/**
	 * Get document count
	 * HTTP loader always returns 1 document per URL
	 *
	 * @return 1
	 */
	numeric function getDocumentCount() {
		return 1;
	}

}
