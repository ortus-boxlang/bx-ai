/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * Loads HTML files and extracts text content.
 * Can extract content from specific tags or the entire document.
 */
class extends="BaseDocumentLoader" {

	/**
	 * Static configuration for HTML loader
	 */
	static {
		DEFAULT_CONFIG = {
			encoding        : "UTF-8",
			includeMetadata : true,
			splitMode       : "none",
			extractTags     : [],
			removeScripts   : true,
			removeStyles    : true,
			removeComments  : true,
			preserveLinks   : false
		};
	}

	/**
	 * Initialize the HTMLLoader
	 *
	 * @source Path to the HTML file or URL
	 * @config Configuration options
	 *
	 * @return HTMLLoader instance
	 */
	function init( string source = "", struct config = {} ) {
		super.init( source: arguments.source, config: {} );
		variables.config = static.DEFAULT_CONFIG.append( arguments.config, true );
		return this;
	}

	/**
	 * Get the loader name
	 *
	 * @return The loader name
	 */
	string function getName() {
		return "HTMLLoader";
	}

	/**
	 * Load the HTML file into Document objects
	 *
	 * @return Array of Document objects
	 */
	array function load() {
		// Validate source exists
		if ( !len( variables.source ) ) {
			throw(
				type    : "HTMLLoader.NoSource",
				message : "No source specified"
			);
		}

		var content  = "";
		var metadata = {};

		// Check if source is a URL or file
		if ( isURL( variables.source ) ) {
			var response = httpRequest( variables.source )
				.setMethod( "GET" )
				.setTimeout( 30 )
				.send();

			content = response.data ?: "";
			metadata = {
				"sourceType"  : "url",
				"url"         : variables.source,
				"statusCode"  : response.statusCode ?: 0
			};
		} else {
			if ( !fileExists( variables.source ) ) {
				throw(
					type    : "HTMLLoader.FileNotFound",
					message : "File not found: #variables.source#"
				);
			}

			content = readFile( variables.source );
			var fileInfo = getSourceInfo();
			metadata = {
				"sourceType"   : "file",
				"fileType"     : "html",
				"fileName"     : fileInfo.name,
				"fileSize"     : fileInfo.size,
				"lastModified" : fileInfo.lastModified
			};
		}

		// Extract title if present
		var titleMatch = reFind( "<title[^>]*>(.*?)</title>", content, 1, true );
		if ( titleMatch.len[ 1 ] > 0 ) {
			metadata[ "title" ] = stripTags( mid( content, titleMatch.pos[ 2 ], titleMatch.len[ 2 ] ) );
		}

		// Extract meta description if present
		var descMatch = reFind( '<meta[^>]*name=["\']description["\'][^>]*content=["\'](.*?)["\']', content, 1, true );
		if ( descMatch.len[ 1 ] > 0 ) {
			metadata[ "description" ] = mid( content, descMatch.pos[ 2 ], descMatch.len[ 2 ] );
		}

		// Process HTML content
		content = processHTML( content );

		// Check if we should extract specific tags
		if ( !variables.config.extractTags.isEmpty() ) {
			return extractByTags( content, metadata );
		}

		// Create single document with all content
		var doc = createDocument(
			content            : content,
			additionalMetadata : metadata
		);

		return [ doc ];
	}

	/**
	 * Check if a string is a URL
	 *
	 * @str The string to check
	 *
	 * @return True if URL
	 */
	private boolean function isURL( required string str ) {
		return reFindNoCase( "^https?://", arguments.str ) > 0;
	}

	/**
	 * Process HTML content - remove unwanted elements and extract text
	 *
	 * @content The raw HTML content
	 *
	 * @return Processed text content
	 */
	private string function processHTML( required string content ) {
		var result = arguments.content;

		// Remove scripts
		if ( variables.config.removeScripts ) {
			result = reReplace( result, "<script[^>]*>[\s\S]*?</script>", "", "all" );
		}

		// Remove styles
		if ( variables.config.removeStyles ) {
			result = reReplace( result, "<style[^>]*>[\s\S]*?</style>", "", "all" );
		}

		// Remove comments
		if ( variables.config.removeComments ) {
			result = reReplace( result, "<!--[\s\S]*?-->", "", "all" );
		}

		// Convert links to text with URL if preserving links
		if ( variables.config.preserveLinks ) {
			result = reReplace( result, '<a[^>]*href=["'']([^"'']+)["''][^>]*>(.*?)</a>', "\2 (\1)", "all" );
		}

		// Replace common block elements with newlines
		result = reReplace( result, "</(p|div|h[1-6]|li|tr|br)[^>]*>", chr( 10 ), "all" );
		result = reReplace( result, "<(p|div|h[1-6]|li|tr)[^>]*>", chr( 10 ), "all" );
		result = reReplace( result, "<br[^>]*>", chr( 10 ), "all" );

		// Strip all remaining HTML tags
		result = stripTags( result );

		// Decode HTML entities
		result = htmlDecode( result );

		// Clean up whitespace
		result = reReplace( result, "[ \t]+", " ", "all" );
		result = reReplace( result, "(\r?\n){3,}", chr( 10 ) & chr( 10 ), "all" );

		return trim( result );
	}

	/**
	 * Strip HTML tags from content
	 *
	 * @content The HTML content
	 *
	 * @return Text without HTML tags
	 */
	private string function stripTags( required string content ) {
		return reReplace( arguments.content, "<[^>]+>", "", "all" );
	}

	/**
	 * Decode HTML entities
	 *
	 * @content The content with HTML entities
	 *
	 * @return Decoded content
	 */
	private string function htmlDecode( required string content ) {
		var result = arguments.content;
		result = replace( result, "&amp;", "&", "all" );
		result = replace( result, "&lt;", "<", "all" );
		result = replace( result, "&gt;", ">", "all" );
		result = replace( result, "&quot;", '"', "all" );
		result = replace( result, "&#39;", "'", "all" );
		result = replace( result, "&apos;", "'", "all" );
		result = replace( result, "&nbsp;", " ", "all" );
		return result;
	}

	/**
	 * Extract content from specific HTML tags
	 *
	 * @content The HTML content
	 * @baseMetadata Base metadata for all documents
	 *
	 * @return Array of Document objects
	 */
	private array function extractByTags( required string content, required struct baseMetadata ) {
		var documents = [];

		for ( var tag in variables.config.extractTags ) {
			var pattern = "<#tag#[^>]*>([\s\S]*?)</#tag#>";
			var matches = reMatch( pattern, arguments.content );

			for ( var i = 1; i <= matches.len(); i++ ) {
				var match = matches[ i ];
				var innerContent = processHTML( match );

				if ( len( trim( innerContent ) ) ) {
					var tagMetadata = duplicate( arguments.baseMetadata );
					tagMetadata[ "extractedTag" ] = tag;
					tagMetadata[ "tagIndex" ]     = i;

					documents.append(
						createDocument(
							content            : innerContent,
							additionalMetadata : tagMetadata
						)
					);
				}
			}
		}

		// If no content found from tags, return full document
		if ( documents.isEmpty() ) {
			documents.append(
				createDocument(
					content            : processHTML( arguments.content ),
					additionalMetadata : arguments.baseMetadata
				)
			);
		}

		return documents;
	}

	/**
	 * Extract content from specific tags
	 *
	 * @tags Array of tag names to extract
	 *
	 * @return HTMLLoader for chaining
	 */
	HTMLLoader function extractTags( required array tags ) {
		variables.config.extractTags = arguments.tags;
		return this;
	}

	/**
	 * Preserve links in output (as "text (url)" format)
	 *
	 * @return HTMLLoader for chaining
	 */
	HTMLLoader function preserveLinks() {
		variables.config.preserveLinks = true;
		return this;
	}

	/**
	 * Keep scripts in output
	 *
	 * @return HTMLLoader for chaining
	 */
	HTMLLoader function keepScripts() {
		variables.config.removeScripts = false;
		return this;
	}

	/**
	 * Keep styles in output
	 *
	 * @return HTMLLoader for chaining
	 */
	HTMLLoader function keepStyles() {
		variables.config.removeStyles = false;
		return this;
	}

}
