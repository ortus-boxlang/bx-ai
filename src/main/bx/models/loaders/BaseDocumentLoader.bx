/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * Abstract base class for document loaders.
 * Provides common functionality for all loader implementations.
 */
import bxModules.bxai.models.memory.IAiMemory;

abstract class implements="IDocumentLoader" {

	/**
	 * The source to load from (file path, URL, etc.)
	 */
	property name="source" type="string" default="";

	/**
	 * Configuration options
	 */
	property name="config" type="struct";

	/**
	 * Documents loaded for batch processing
	 */
	property name="documents" type="array";

	/**
	 * Current index for batch iteration
	 */
	property name="currentIndex" type="numeric" default="0";

	/**
	 * Whether documents have been loaded
	 */
	property name="documentsLoaded" type="boolean" default="false";

	/**
	 * Errors encountered during loading
	 */
	property name="errors" type="array";

	/**
	 * Static default configuration
	 */
	static {
		DEFAULT_CONFIG = {
			encoding          : "UTF-8",
			includeMetadata   : true,
			splitMode         : "none",
			continueOnError   : true
		};
	}

	/**
	 * Initialize the loader
	 *
	 * @source The source to load from
	 * @config Configuration options
	 *
	 * @return BaseDocumentLoader instance
	 */
	function init( string source = "", struct config = {} ) {
		variables.source          = arguments.source;
		variables.config          = duplicate( static.DEFAULT_CONFIG ).append( arguments.config, true );
		variables.documents       = [];
		variables.currentIndex    = 0;
		variables.documentsLoaded = false;
		variables.errors          = [];
		return this;
	}

	/**
	 * Get the name of this loader (uses class name by default)
	 *
	 * @return The loader name
	 */
	string function getName() {
		var metadata = getMetadata( this );
		return metadata.keyExists( "name" ) ? metadata.name : "DocumentLoader";
	}

	/**
	 * Set the source and reset state
	 *
	 * @source The source to load from
	 *
	 * @return BaseDocumentLoader for chaining
	 */
	function setSource( required string source ) {
		variables.source = arguments.source;
		// Reset state when source changes
		variables.documentsLoaded = false;
		variables.currentIndex    = 0;
		variables.documents       = [];
		variables.errors          = [];
		return this;
	}

	/**
	 * Configure the loader
	 *
	 * @config Configuration struct to merge
	 *
	 * @return IDocumentLoader for chaining
	 */
	IDocumentLoader function configure( required struct config ) {
		variables.config.append( arguments.config, true );
		return this;
	}

	/**
	 * Get metadata about the source without loading documents
	 *
	 * @return Struct with source metadata
	 */
	struct function getSourceMetadata() {
		var metadata = {
			"source"       : variables.source,
			"loader"       : getName(),
			"exists"       : sourceExists(),
			"isDirectory"  : directoryExists( variables.source ),
			"isFile"       : fileExists( variables.source ),
			"isURL"        : variables.source.lCase().startsWith( "http://" ) || variables.source.lCase().startsWith( "https://" )
		};

		// Add file info if it exists
		if ( metadata.isFile || metadata.isDirectory ) {
			var info = getSourceInfo();
			metadata.append( info, true );
		}

		return metadata;
	}

	/**
	 * Get total document count if known
	 * Default returns -1 (unknown) for streaming loaders
	 * Subclasses can override for accurate counts
	 *
	 * @return Numeric count or -1 if unknown
	 */
	numeric function getDocumentCount() {
		// If already loaded, return actual count
		if ( variables.documentsLoaded ) {
			return variables.documents.len();
		}
		// Default to -1 (unknown) for unloaded sources
		return -1;
	}

	/**
	 * Load documents in batches
	 * Default implementation loads all and returns a slice
	 *
	 * @batchSize Number of documents per batch
	 *
	 * @return Array of Documents (up to batchSize)
	 */
	array function loadBatch( numeric batchSize = 100 ) {
		// Ensure documents are loaded
		if ( !variables.documentsLoaded ) {
			variables.documents       = load();
			variables.documentsLoaded = true;
		}

		// Return slice from current position
		var startPos = variables.currentIndex + 1;
		var endPos   = min( variables.currentIndex + arguments.batchSize, variables.documents.len() );

		if ( startPos > variables.documents.len() ) {
			return [];
		}

		var batch = variables.documents.slice( startPos, endPos - startPos + 1 );
		variables.currentIndex = endPos;
		return batch;
	}

	/**
	 * Load documents as a Java Stream
	 * Provides lazy evaluation for memory-efficient processing
	 *
	 * @return Java Stream of Document objects
	 */
	any function loadAsStream() {
		// Load documents if not yet loaded
		if ( !variables.documentsLoaded ) {
			variables.documents       = load();
			variables.documentsLoaded = true;
		}

		// Convert to Java Stream using the stream() method on arrays
		return variables.documents.stream();
	}

	/**
	 * Load all documents from the source
	 * Subclasses must override this method.
	 *
	 * @return Array of Document objects
	 */
	array function load() {
		throw(
			type    : "BaseDocumentLoader.NotImplemented",
			message : "Subclasses must override the load() method"
		);
	}

	/**
	 * Get errors encountered during loading
	 *
	 * @return Array of error structs
	 */
	array function getErrors() {
		return variables.errors;
	}

	/**
	 * Add an error to the errors array
	 *
	 * @error The error struct or message
	 *
	 * @return BaseDocumentLoader for chaining
	 */
	function addError( required any error ) {
		if ( isSimpleValue( arguments.error ) ) {
			variables.errors.append( {
				"message" : arguments.error,
				"source"  : variables.source,
				"time"    : now()
			} );
		} else {
			variables.errors.append( arguments.error );
		}
		return this;
	}

	/**
	 * Create a new Document with standard metadata
	 *
	 * @content The document content
	 * @additionalMetadata Additional metadata to merge
	 * @id Optional explicit document ID (auto-generated if not provided)
	 *
	 * @return Document instance
	 */
	Document function createDocument( required string content, struct additionalMetadata = {}, string id = "" ) {
		var baseMetadata = {
			"source"   : variables.source,
			"loader"   : getName(),
			"loadedAt" : now()
		};

		// Merge additional metadata
		baseMetadata.append( arguments.additionalMetadata, true );

		return new Document(
			id       : arguments.id,
			content  : arguments.content,
			metadata : baseMetadata
		);
	}

	/**
	 * Read file content with specified encoding
	 *
	 * @filePath Path to the file
	 *
	 * @return File content as string
	 */
	string function readFile( required string filePath ) {
		return fileRead( arguments.filePath, variables.config.encoding );
	}

	/**
	 * Check if the source file exists
	 *
	 * @return True if file exists
	 */
	boolean function sourceExists() {
		return fileExists( variables.source ) || directoryExists( variables.source );
	}

	/**
	 * Get file info for the source
	 *
	 * @return Struct with file information
	 */
	struct function getSourceInfo() {
		if ( !sourceExists() ) {
			return {};
		}

		var info = getFileInfo( variables.source );
		return {
			"name"         : info.name,
			"path"         : info.path,
			"size"         : info.size,
			"lastModified" : info.lastModified,
			"type"         : info.type,
			"canRead"      : info.canRead
		};
	}

	/**
	 * Load documents and store them to a memory instance
	 *
	 * @memory The memory instance to store documents in
	 * @chunkOptions Options for chunking (if provided, documents will be chunked before storing)
	 *
	 * @return Array of Document objects that were stored
	 */
	array function loadTo( required IAiMemory memory, struct chunkOptions = {} ) {
		var docs = load();

		// If chunk options provided, chunk the documents
		if ( !arguments.chunkOptions.isEmpty() ) {
			docs = chunkDocuments( docs, arguments.chunkOptions );
		}

		// Use the memory's seed method to store documents
		arguments.memory.seed( docs );

		return docs;
	}

	/**
	 * Chunk documents into smaller segments
	 *
	 * @documents Array of documents to chunk
	 * @options Chunking options (chunkSize, overlap, strategy)
	 *
	 * @return Array of chunked Document objects
	 */
	array function chunkDocuments( required array documents, struct options = {} ) {
		var chunkedDocs = [];

		for ( var doc in arguments.documents ) {
			var chunks = aiChunk( text: doc.getContent(), options: arguments.options );

			for ( var i = 1; i <= chunks.len(); i++ ) {
				var chunkMetadata = duplicate( doc.getMetadata() );
				chunkMetadata[ "chunkIndex" ]  = i;
				chunkMetadata[ "totalChunks" ] = chunks.len();
				chunkMetadata[ "isChunk" ]     = true;
				chunkMetadata[ "parentId" ]    = doc.getId();

				chunkedDocs.append(
					new Document(
						content  : chunks[ i ],
						metadata : chunkMetadata
					)
				);
			}
		}

		return chunkedDocs;
	}

}
