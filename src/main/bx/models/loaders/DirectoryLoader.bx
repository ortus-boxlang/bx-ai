/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * Loads all files from a directory using appropriate loaders.
 * Automatically selects the right loader based on file extension.
 */
import bxModules.bxai.models.loaders.TextLoader
import bxModules.bxai.models.loaders.MarkdownLoader
import bxModules.bxai.models.loaders.CSVLoader
import bxModules.bxai.models.loaders.JSONLoader
import bxModules.bxai.models.loaders.XMLLoader
import bxModules.bxai.models.loaders.FeedLoader

class extends="BaseDocumentLoader" {

	/**
	 * Custom loader mappings
	 */
	property name="loaderMappings" type="struct";

	/**
	 * Custom filter callback function
	 */
	property name="filterCallback" type="any";

	/**
	 * Static configuration and loader mappings
	 */
	static {
		DEFAULT_CONFIG = {
			encoding        : "UTF-8",
			includeMetadata : true,
			recursive       : false,
			extensions      : [],
			excludePatterns : [],
			includeHidden   : false
		}

		LOADER_MAP = {
			"txt"  : "TextLoader",
			"text" : "TextLoader",
			"md"   : "MarkdownLoader",
			"markdown" : "MarkdownLoader",
			"csv"  : "CSVLoader",
			"json" : "JSONLoader",
			"xml"  : "XMLLoader",
			"rss"  : "FeedLoader"
		}
	}

	/**
	 * Initialize the DirectoryLoader
	 *
	 * @source Path to the directory
	 * @config Configuration options
	 *
	 * @return DirectoryLoader instance
	 */
	function init( string source = "", struct config = {} ) {
		super.init( argumentCollection: arguments )
		variables.config         = duplicate( static.DEFAULT_CONFIG ).append( arguments.config, true )
		variables.loaderMappings = duplicate( static.LOADER_MAP )
		variables.filterCallback = ""
		return this
	}

	/**
	 * Load all files from the directory
	 *
	 * @return Array of Document objects
	 */
	array function doLoad() {
		// Validate source exists
		if ( !len( variables.source ) ) {
			throw(
				type    : "DirectoryLoader.NoSource",
				message : "No source directory specified"
			)
		}

		if ( !directoryExists( variables.source ) ) {
			throw(
				type    : "DirectoryLoader.DirectoryNotFound",
				message : "Directory not found: #variables.source#"
			)
		}

		var documents = []
		var files     = getFiles( variables.source )

		for ( var filePath in files ) {
			var loader = getLoaderForFile( filePath )

			if ( !isNull( loader ) ) {
				try {
					var fileDocs = loader.load()
					documents.append( fileDocs, true )
				} catch ( any e ) {
					// Log error but continue with other files
					if ( variables.config.includeMetadata ) {
						documents.append(
							createDocument(
								content            : "",
								additionalMetadata : {
									"loadError" : e.message,
									"filePath"  : filePath,
									"errorType" : e.type
								}
							)
						)
					}
				}
			}
		}

		return documents
	}

	/**
	 * Get all files from directory (optionally recursive)
	 *
	 * @directory The directory path
	 *
	 * @return Array of file paths
	 */
	private array function getFiles( required string directory ) {
		var files     = []
		var contents  = directoryList( arguments.directory, variables.config.recursive, "path" )

		for ( var item in contents ) {
			// Skip directories
			if ( directoryExists( item ) ) {
				continue
			}

			// Skip hidden files if configured
			if ( !variables.config.includeHidden && isHiddenFile( item ) ) {
				continue
			}

			// Check if file matches filters
			if ( shouldIncludeFile( item ) ) {
				files.append( item )
			}
		}

		return files
	}

	/**
	 * Check if a file is hidden
	 *
	 * @filePath The file path
	 *
	 * @return True if hidden
	 */
	private boolean function isHiddenFile( required string filePath ) {
		var fileName = listLast( arguments.filePath, "/\" )
		return left( fileName, 1 ) == "."
	}

	/**
	 * Check if a file should be included based on filters
	 *
	 * @filePath The file path
	 *
	 * @return True if file should be included
	 */
	private boolean function shouldIncludeFile( required string filePath ) {
		var extension = listLast( arguments.filePath, "." ).lCase()
		var fileName  = listLast( arguments.filePath, "/\" )

		// Check extension filter
		if ( !variables.config.extensions.isEmpty() ) {
			var normalizedExtensions = variables.config.extensions.map( ext => ext.lCase().replace( ".", "" ) )
			if ( !normalizedExtensions.findNoCase( extension ) ) {
				return false
			}
		}

		// Check exclude patterns
		for ( var pattern in variables.config.excludePatterns ) {
			if ( reFindNoCase( pattern, fileName ) ) {
				return false
			}
		}

		// Apply custom filter callback if set
		if ( isCustomFunction( variables.filterCallback ) || isClosure( variables.filterCallback ) ) {
			return variables.filterCallback( arguments.filePath )
		}

		// Check if we have a loader for this extension
		if ( !variables.loaderMappings.keyExists( extension ) ) {
			return false
		}

		return true
	}

	/**
	 * Get the appropriate loader for a file
	 *
	 * @filePath The file path
	 *
	 * @return IDocumentLoader instance or null
	 */
	private any function getLoaderForFile( required string filePath ) {
		var extension = listLast( arguments.filePath, "." ).lcase()

		if ( !variables.loaderMappings.keyExists( extension ) ) {
			return null
		}

		var loaderName = variables.loaderMappings[ extension ]

		// Create the appropriate loader
		switch ( loaderName ) {
			case "TextLoader":
				return new TextLoader( source: arguments.filePath, config: variables.config )
			case "MarkdownLoader":
				return new MarkdownLoader( source: arguments.filePath, config: variables.config )
			case "CSVLoader":
				return new CSVLoader( source: arguments.filePath, config: variables.config )
			case "JSONLoader":
				return new JSONLoader( source: arguments.filePath, config: variables.config )
			case "XMLLoader":
				return new XMLLoader( source: arguments.filePath, config: variables.config )
			case "FeedLoader":
				return new FeedLoader( source: arguments.filePath, config: variables.config )
			default:
				return null
		}
	}

	/**
	 * Enable recursive directory scanning
	 *
	 * @return DirectoryLoader for chaining
	 */
	DirectoryLoader function recursive() {
		variables.config.recursive = true
		return this
	}

	/**
	 * Filter by specific file extensions
	 *
	 * @extensions Array of extensions (e.g., ["txt", "md"])
	 *
	 * @return DirectoryLoader for chaining
	 */
	DirectoryLoader function extensions( required array extensions ) {
		variables.config.extensions = arguments.extensions
		return this
	}

	/**
	 * Set custom filter callback for file filtering
	 *
	 * @callback Function that receives filePath and returns boolean: ( filePath ) => boolean
	 *
	 * @return DirectoryLoader for chaining
	 */
	DirectoryLoader function filterFiles( required function callback ) {
		variables.filterCallback = arguments.callback
		return this
	}

	/**
	 * Exclude files matching patterns
	 *
	 * @patterns Array of regex patterns to exclude
	 *
	 * @return DirectoryLoader for chaining
	 */
	DirectoryLoader function exclude( required array patterns ) {
		variables.config.excludePatterns = arguments.patterns
		return this
	}

	/**
	 * Include hidden files
	 *
	 * @return DirectoryLoader for chaining
	 */
	DirectoryLoader function includeHidden() {
		variables.config.includeHidden = true
		return this
	}

	/**
	 * Exclude hidden files
	 *
	 * @return DirectoryLoader for chaining
	 */
	DirectoryLoader function excludeHidden() {
		variables.config.includeHidden = false
		return this
	}

	/**
	 * Register a custom loader for an extension
	 *
	 * @extension The file extension
	 * @loaderName The loader class name
	 *
	 * @return DirectoryLoader for chaining
	 */
	DirectoryLoader function registerLoader( required string extension, required string loaderName ) {
		variables.loaderMappings[ arguments.extension.lCase() ] = arguments.loaderName
		return this
	}

}
