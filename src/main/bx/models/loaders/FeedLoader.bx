/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------------
 * Loads and parses RSS and Atom feeds.
 * Each feed item/entry becomes a separate Document.
 * Supports blog aggregation, news feeds, and content syndication.
 */
class extends="BaseDocumentLoader" {

	/**
	 * Static configuration
	 */
	static {
		DEFAULT_CONFIG = {
			encoding           : "UTF-8",
			includeMetadata    : true,
			// Content options
			includeDescription : true,
			includeContent     : true,
			stripHtml          : true,
			// Filtering
			maxItems           : 0,
			sinceDate          : "",
			categories         : [],
			// HTTP options for URL sources
			timeout            : 30,
			userAgent          : "BoxLang-FeedLoader/1.0"
		};
	}

	/**
	 * Initialize the FeedLoader
	 *
	 * @source Path to feed file or feed URL
	 * @config Configuration options
	 *
	 * @return FeedLoader instance
	 */
	function init( string source = "", struct config = {} ) {
		super.init( source: arguments.source, config: {} );
		variables.config = duplicate( static.DEFAULT_CONFIG ).append( arguments.config, true );
		return this;
	}

	/**
	 * Get the loader name
	 *
	 * @return The loader name
	 */
	string function getName() {
		return "FeedLoader";
	}

	/**
	 * Load and parse the feed
	 *
	 * @return Array of Document objects (one per feed item)
	 */
	array function load() {
		if ( !len( variables.source ) ) {
			throw(
				type    : "FeedLoader.NoSource",
				message : "No feed source specified"
			);
		}

		var feedContent = "";

		// Load feed content from URL or file
		if ( isURL( variables.source ) ) {
			feedContent = loadFromURL( variables.source );
		} else if ( fileExists( variables.source ) ) {
			feedContent = readFile( variables.source );
		} else {
			throw(
				type    : "FeedLoader.InvalidSource",
				message : "Feed source not found: #variables.source#"
			);
		}

		// Parse the feed XML
		var feedXML = xmlParse( feedContent );
		var feedType = detectFeedType( feedXML );

		// Parse based on feed type
		switch ( feedType ) {
			case "rss":
				return parseRSS( feedXML );
			case "atom":
				return parseAtom( feedXML );
			default:
				throw(
					type    : "FeedLoader.UnknownFeedType",
					message : "Unable to detect feed type. Supported types: RSS 2.0, Atom"
				);
		}
	}

	/**
	 * Check if source is a URL
	 *
	 * @source The source string
	 *
	 * @return True if URL
	 */
	private boolean function isURL( required string source ) {
		return arguments.source.lCase().reFind( "^https?://" ) > 0;
	}

	/**
	 * Load feed content from URL
	 *
	 * @feedUrl The feed URL
	 *
	 * @return Feed XML content
	 */
	private string function loadFromURL( required string feedUrl ) {
		var response = http( url: arguments.feedUrl, timeout: variables.config.timeout )
			.addHeader( "User-Agent", variables.config.userAgent )
			.addHeader( "Accept", "application/rss+xml, application/atom+xml, application/xml, text/xml" )
			.get()
			.send();

		if ( response.statusCode < 200 || response.statusCode >= 300 ) {
			throw(
				type    : "FeedLoader.HTTPError",
				message : "Failed to fetch feed: HTTP #response.statusCode#",
				detail  : response.fileContent ?: ""
			);
		}

		return response.fileContent;
	}

	/**
	 * Detect the feed type (RSS or Atom)
	 *
	 * @feedXML The parsed XML document
	 *
	 * @return Feed type string
	 */
	private string function detectFeedType( required any feedXML ) {
		var rootName = arguments.feedXML.xmlRoot.xmlName.lCase();

		if ( rootName == "rss" || rootName == "rdf:rdf" ) {
			return "rss";
		} else if ( rootName == "feed" ) {
			return "atom";
		}

		return "unknown";
	}

	/**
	 * Parse RSS 2.0 feed
	 *
	 * @feedXML The parsed XML document
	 *
	 * @return Array of Document objects
	 */
	private array function parseRSS( required any feedXML ) {
		var documents = [];
		var items = xmlSearch( arguments.feedXML, "//item" );

		// Get channel info for metadata
		var channelTitle = getXMLValue( arguments.feedXML, "//channel/title" );
		var channelLink = getXMLValue( arguments.feedXML, "//channel/link" );
		var channelDescription = getXMLValue( arguments.feedXML, "//channel/description" );

		var itemCount = 0;
		for ( var item in items ) {
			// Check max items limit
			if ( variables.config.maxItems > 0 && itemCount >= variables.config.maxItems ) {
				break;
			}

			// Extract item data
			var title = getElementText( item, "title" );
			var link = getElementText( item, "link" );
			var description = getElementText( item, "description" );
			var content = getElementText( item, "content:encoded" );
			var pubDate = getElementText( item, "pubDate" );
			var author = getElementText( item, "author" );
			var guid = getElementText( item, "guid" );
			var categories = getElementTexts( item, "category" );

			// Filter by date if configured
			if ( len( variables.config.sinceDate ) && len( pubDate ) ) {
				try {
					var itemDate = parseDateTime( pubDate );
					var sinceDate = parseDateTime( variables.config.sinceDate );
					if ( itemDate < sinceDate ) {
						continue;
					}
				} catch ( any e ) {
					// Skip date filtering if parse fails
				}
			}

			// Filter by categories if configured
			if ( variables.config.categories.len() > 0 ) {
				var hasCategory = false;
				for ( var cat in categories ) {
					if ( variables.config.categories.findNoCase( cat ) ) {
						hasCategory = true;
						break;
					}
				}
				if ( !hasCategory ) {
					continue;
				}
			}

			// Build content
			var docContent = buildContent( title, description, content );

			// Build metadata
			var metadata = {
				"feedType"        : "rss",
				"feedTitle"       : channelTitle,
				"feedLink"        : channelLink,
				"itemTitle"       : title,
				"itemLink"        : link,
				"pubDate"         : pubDate,
				"author"          : author,
				"guid"            : guid,
				"categories"      : categories
			};

			documents.append(
				createDocument(
					content            : docContent,
					additionalMetadata : metadata,
					id                 : len( guid ) ? guid : link
				)
			);

			itemCount++;
		}

		return documents;
	}

	/**
	 * Parse Atom feed
	 *
	 * @feedXML The parsed XML document
	 *
	 * @return Array of Document objects
	 */
	private array function parseAtom( required any feedXML ) {
		var documents = [];
		var entries = xmlSearch( arguments.feedXML, "//*[local-name()='entry']" );

		// Get feed info for metadata
		var feedTitle = getXMLValue( arguments.feedXML, "//*[local-name()='feed']/*[local-name()='title']" );
		var feedLink = getAtomLink( arguments.feedXML.xmlRoot );

		var entryCount = 0;
		for ( var entry in entries ) {
			// Check max items limit
			if ( variables.config.maxItems > 0 && entryCount >= variables.config.maxItems ) {
				break;
			}

			// Extract entry data
			var title = getElementText( entry, "*[local-name()='title']" );
			var link = getAtomLink( entry );
			var summary = getElementText( entry, "*[local-name()='summary']" );
			var content = getElementText( entry, "*[local-name()='content']" );
			var published = getElementText( entry, "*[local-name()='published']" );
			var updated = getElementText( entry, "*[local-name()='updated']" );
			var author = getElementText( entry, "*[local-name()='author']/*[local-name()='name']" );
			var entryId = getElementText( entry, "*[local-name()='id']" );
			var categories = getAtomCategories( entry );

			// Use published or updated date
			var pubDate = len( published ) ? published : updated;

			// Filter by date if configured
			if ( len( variables.config.sinceDate ) && len( pubDate ) ) {
				try {
					var entryDate = parseDateTime( pubDate );
					var sinceDate = parseDateTime( variables.config.sinceDate );
					if ( entryDate < sinceDate ) {
						continue;
					}
				} catch ( any e ) {
					// Skip date filtering if parse fails
				}
			}

			// Filter by categories if configured
			if ( variables.config.categories.len() > 0 ) {
				var hasCategory = false;
				for ( var cat in categories ) {
					if ( variables.config.categories.findNoCase( cat ) ) {
						hasCategory = true;
						break;
					}
				}
				if ( !hasCategory ) {
					continue;
				}
			}

			// Build content
			var docContent = buildContent( title, summary, content );

			// Build metadata
			var metadata = {
				"feedType"        : "atom",
				"feedTitle"       : feedTitle,
				"feedLink"        : feedLink,
				"entryTitle"      : title,
				"entryLink"       : link,
				"published"       : published,
				"updated"         : updated,
				"author"          : author,
				"entryId"         : entryId,
				"categories"      : categories
			};

			documents.append(
				createDocument(
					content            : docContent,
					additionalMetadata : metadata,
					id                 : len( entryId ) ? entryId : link
				)
			);

			entryCount++;
		}

		return documents;
	}

	/**
	 * Build document content from feed item parts
	 *
	 * @title Item title
	 * @description Item description/summary
	 * @content Full content (if available)
	 *
	 * @return Combined content string
	 */
	private string function buildContent(
		required string title,
		required string description,
		required string content
	) {
		var parts = [];

		if ( len( arguments.title ) ) {
			parts.append( arguments.title );
		}

		if ( variables.config.includeDescription && len( arguments.description ) ) {
			var desc = variables.config.stripHtml ? stripHTML( arguments.description ) : arguments.description;
			parts.append( desc );
		}

		if ( variables.config.includeContent && len( arguments.content ) ) {
			var cont = variables.config.stripHtml ? stripHTML( arguments.content ) : arguments.content;
			parts.append( cont );
		}

		return parts.toList( char( 10 ) & char( 10 ) );
	}

	/**
	 * Strip HTML tags from text
	 *
	 * @text HTML text
	 *
	 * @return Plain text
	 */
	private string function stripHTML( required string text ) {
		// Remove HTML tags
		var result = arguments.text.reReplace( "<[^>]*>", " ", "all" );
		// Decode HTML entities
		result = result.replace( "&nbsp;", " ", "all" )
			.replace( "&amp;", "&", "all" )
			.replace( "&lt;", "<", "all" )
			.replace( "&gt;", ">", "all" )
			.replace( "&quot;", """", "all" )
			.replace( "&#39;", "'", "all" );
		// Normalize whitespace
		result = result.reReplace( "\s+", " ", "all" ).trim();
		return result;
	}

	/**
	 * Get text from XML element by name
	 *
	 * @parent Parent element
	 * @childName Child element name
	 *
	 * @return Element text or empty string
	 */
	private string function getElementText( required any parent, required string childName ) {
		try {
			var elements = xmlSearch( arguments.parent, arguments.childName );
			if ( elements.len() > 0 ) {
				return elements[ 1 ].xmlText ?: "";
			}
		} catch ( any e ) {
			// Element not found
		}
		return "";
	}

	/**
	 * Get multiple text values from XML elements
	 *
	 * @parent Parent element
	 * @childName Child element name
	 *
	 * @return Array of text values
	 */
	private array function getElementTexts( required any parent, required string childName ) {
		var texts = [];
		try {
			var elements = xmlSearch( arguments.parent, arguments.childName );
			for ( var element in elements ) {
				if ( len( element.xmlText ?: "" ) ) {
					texts.append( element.xmlText );
				}
			}
		} catch ( any e ) {
			// Elements not found
		}
		return texts;
	}

	/**
	 * Get XML value using XPath
	 *
	 * @xmlDoc XML document
	 * @xpath XPath expression
	 *
	 * @return Value or empty string
	 */
	private string function getXMLValue( required any xmlDoc, required string xpath ) {
		try {
			var elements = xmlSearch( arguments.xmlDoc, arguments.xpath );
			if ( elements.len() > 0 ) {
				return elements[ 1 ].xmlText ?: "";
			}
		} catch ( any e ) {
			// Not found
		}
		return "";
	}

	/**
	 * Get link from Atom entry (handles different link types)
	 *
	 * @element Atom entry element
	 *
	 * @return Link URL
	 */
	private string function getAtomLink( required any element ) {
		try {
			var links = xmlSearch( arguments.element, "*[local-name()='link']" );
			for ( var link in links ) {
				var rel = link.xmlAttributes[ "rel" ] ?: "alternate";
				if ( rel == "alternate" || rel == "" ) {
					return link.xmlAttributes[ "href" ] ?: "";
				}
			}
			// Fall back to first link
			if ( links.len() > 0 ) {
				return links[ 1 ].xmlAttributes[ "href" ] ?: "";
			}
		} catch ( any e ) {
			// No links found
		}
		return "";
	}

	/**
	 * Get categories from Atom entry
	 *
	 * @element Atom entry element
	 *
	 * @return Array of category terms
	 */
	private array function getAtomCategories( required any element ) {
		var categories = [];
		try {
			var catElements = xmlSearch( arguments.element, "*[local-name()='category']" );
			for ( var cat in catElements ) {
				var term = cat.xmlAttributes[ "term" ] ?: "";
				if ( len( term ) ) {
					categories.append( term );
				}
			}
		} catch ( any e ) {
			// No categories
		}
		return categories;
	}

	// ==========================================
	// Fluent Configuration Methods
	// ==========================================

	/**
	 * Include item description in content
	 *
	 * @include Whether to include description
	 *
	 * @return FeedLoader for chaining
	 */
	FeedLoader function includeDescription( boolean include = true ) {
		variables.config.includeDescription = arguments.include;
		return this;
	}

	/**
	 * Include full content in document
	 *
	 * @include Whether to include content
	 *
	 * @return FeedLoader for chaining
	 */
	FeedLoader function includeContent( boolean include = true ) {
		variables.config.includeContent = arguments.include;
		return this;
	}

	/**
	 * Strip HTML from content
	 *
	 * @strip Whether to strip HTML
	 *
	 * @return FeedLoader for chaining
	 */
	FeedLoader function stripHtml( boolean strip = true ) {
		variables.config.stripHtml = arguments.strip;
		return this;
	}

	/**
	 * Limit number of items to load
	 *
	 * @max Maximum items (0 = no limit)
	 *
	 * @return FeedLoader for chaining
	 */
	FeedLoader function maxItems( required numeric max ) {
		variables.config.maxItems = arguments.max;
		return this;
	}

	/**
	 * Only load items published since date
	 *
	 * @date Date string or date object
	 *
	 * @return FeedLoader for chaining
	 */
	FeedLoader function sinceDate( required any date ) {
		variables.config.sinceDate = isDate( arguments.date ) ? dateFormat( arguments.date, "yyyy-mm-dd" ) : arguments.date;
		return this;
	}

	/**
	 * Filter by categories
	 *
	 * @categories Array of category names to include
	 *
	 * @return FeedLoader for chaining
	 */
	FeedLoader function categories( required array categories ) {
		variables.config.categories = arguments.categories;
		return this;
	}

	/**
	 * Set request timeout for URL sources
	 *
	 * @seconds Timeout in seconds
	 *
	 * @return FeedLoader for chaining
	 */
	FeedLoader function timeout( required numeric seconds ) {
		variables.config.timeout = arguments.seconds;
		return this;
	}

}
